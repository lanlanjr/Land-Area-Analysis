<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>GIS Land Area Analysis</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --vh: 1vh;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%; /* Fallback */
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
            position: fixed;
            font-family: Arial, sans-serif;
            /* Safe area insets to protect from notches and home indicators */
            padding-bottom: env(safe-area-inset-bottom);
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            /* Fallback values for browsers that don't support env() */
            padding-bottom: constant(safe-area-inset-bottom, 20px);
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100%; /* Fallback */
            height: calc(var(--vh, 1vh) * 100);
            width: 100%;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .sidebar {
            width: 100%;
            padding: 15px;
            background-color: #f8f9fa;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: auto;
            max-height: 50%;
            transition: all 0.3s ease-in-out;
            position: relative;
            z-index: 100;
            box-sizing: border-box;
        }
        
        /* Sidebar toggle */
        .sidebar-toggle {
            display: none;
            position: absolute;
            top: 20px;
            right: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            text-align: center;
            font-size: 18px;
            line-height: 36px;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        
        .sidebar-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        
        .sidebar-toggle:active {
            transform: scale(0.95);
        }
        
        .sidebar.collapsed {
            max-height: 80px;
            overflow: hidden;
            /* Maintain full width when collapsed */
            width: 100%;
            min-width: auto;
            min-height: 80px;
            transition: all 0.3s ease;
        }
        
        /* Desktop styles */
        @media (min-width: 992px) {
            .container {
                flex-direction: row;
            }
            .sidebar {
                width: 400px;
                max-height: 100%;
                height: 100%;
            }
            .sidebar-toggle {
                display: block; /* Allow toggle on all device sizes */
            }
            .sidebar.collapsed {
                max-height: 60px;
                width: 400px;
                min-width: 400px;
            }
            
            .map-container {
                flex: 1;
                transition: all 0.3s ease;
                height: 100%;
            }
        }
        .sidebar-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        .section-title {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
        }
        .styled-select {
            flex: 1;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
            color: #495057;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23888' viewBox='0 0 12 12'%3E%3Cpath d='M3 5l3 3 3-3'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            cursor: pointer;
        }
        .styled-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        /* Styled Radio Buttons */
        .styled-radio {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid #2196F3;
            border-radius: 50%;
            background-color: #ffffff;
            margin-right: 8px;
            position: relative;
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
        }

        .styled-radio:checked {
            background-color: #ffffff;
        }

        .styled-radio:checked::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #2196F3;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .styled-radio:disabled {
            border-color: #b0b0b0;
            background-color: #f0f0f0;
            cursor: not-allowed;
        }

        .styled-radio:disabled:checked::after {
            background-color: #b0b0b0;
        }

        .radio-label {
            cursor: pointer;
            font-size: 14px;
            user-select: none;
        }
        .checkbox-label {
            font-weight: 500;
            margin: 0;
            cursor: pointer;
            color: #495057;
        }
        .primary-btn {
            padding: 12px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .primary-btn:hover {
            background-color: #3e8e41;
        }
        .primary-btn:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
        }
        .secondary-btn {
            padding: 12px 15px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        .secondary-btn:hover {
            background-color: #0b7dda;
        }
        .secondary-btn:disabled {
            background-color: #cccccc;
            color: #888888;
            cursor: not-allowed;
        }
        .info-message {
            display: flex;
            align-items: flex-start;
            padding: 12px 15px;
            background-color: #e9f7fe;
            border-left: 4px solid #3498db;
            border-radius: 4px;
        }
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 20px;
            border-radius: 50%;
            background-color: #3498db;
            color: white;
            font-style: normal;
            font-weight: bold;
            margin-right: 10px;
            font-size: 12px;
        }
        .info-message p {
            margin: 0;
            color: #2c3e50;
        }
        .map-container {
            flex: 1;
            position: relative;
            height: 50%;
            min-height: 200px;
            /* Ensure room for mobile safe area at bottom */
            padding-bottom: env(safe-area-inset-bottom, 0px);
            box-sizing: border-box;
            transition: all 0.3s ease-in-out;
        }
        
        /* Adjust map container height when sidebar is collapsed on mobile */
        @media (max-width: 991px) {
            .sidebar.collapsed + .map-container {
                height: calc(100% - 80px);
                min-height: calc(100% - 80px);
            }
        }
        
        @media (min-width: 992px) {
            .map-container {
                height: 100%;
            }
        }
        
        #map {
            height: 100%;
            width: 100%;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }
        
        input[type="date"] {
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        .results {
            background-color: #fff;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .error {
            color: #dc3545;
            font-weight: bold;
            padding: 12px 15px;
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .stats-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }
        .stats-title {
            font-weight: 600;
            margin-bottom: 12px;
            color: #2c3e50;
            font-size: 15px;
        }
        .stat-item {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            background-color: #f8f9fa;
            padding: 8px 12px;
            border-radius: 4px;
        }
        .stat-label {
            color: #6c757d;
        }
        .stat-value {
            font-weight: 600;
            color: #2c3e50;
        }
        .vegetation-type {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 6px;
            background-color: #f8f9fa;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .vegetation-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .vegetation-name {
            font-weight: 600;
            color: #2c3e50;
        }
        .vegetation-area {
            color: #6c757d;
            font-weight: 500;
        }
        .progress-bar {
            height: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .legend {
            padding: 15px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .time-series {
            background-color: #fff;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 15px;
            background-color: #fff;
            border-radius: 4px;
            padding: 10px;
            border: 1px solid #e9ecef;
        }
        
        .year-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-direction: column;
        }
        
        .year-selector select {
            width: 100%;
            padding: 12px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        
        @media (min-width: 576px) {
            .year-selector {
                flex-direction: row;
            }
            
            .year-selector select {
                flex: 1;
                margin-bottom: 0;
            }
        }
        
        /* Time series button styles removed - now using .primary-btn and .secondary-btn */
        
        .tab-container {
            margin-top: 15px;
        }
        
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .tab-btn {
            padding: 8px 15px;
            border: none;
            background-color: #848484;
            cursor: pointer;
            border-radius: 4px;
            flex: 1;
        }
        
        .tab-btn.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .animation-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.25);
            z-index: 1000;
            display: none;
            max-width: 100%;
            width: 300px;
            box-sizing: border-box;
        }
        
        .animation-controls.visible {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
        }
        
        /* Animation collapse/expand functionality */
        .animation-collapse-btn {
            background: rgba(0,0,0,0.03);
            border: none;
            color: #555;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            margin-left: 5px;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: none;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        
        .animation-collapse-btn:hover {
            background-color: rgba(0,0,0,0.1);
        }
        
        .animation-collapse-btn:active {
            background-color: rgba(0,0,0,0.15);
            transform: scale(0.95);
        }
        
        .animation-controls.collapsed {
            width: auto;
            padding: 6px 10px;
            border-radius: 30px;
            opacity: 0.8;
            max-width: min-content;
            background-color: rgba(255, 255, 255, 0.9);
        }
        
        .animation-controls.collapsed .animation-row:not(.animation-primary-row),
        .animation-controls.collapsed .timeline-slider,
        .animation-controls.collapsed .speed-control {
            display: none;
        }
        
        .animation-controls.collapsed .animation-collapse-btn {
            transform: rotate(180deg);
        }
        
        .animation-controls.collapsed .play-pause-btn {
            margin-right: 4px;
        }
        
        /* When collapsed, make sure year display is visible but compact */
        .animation-controls.collapsed .year-display {
            min-width: 44px;
            font-size: 13px;
            padding: 3px 4px;
        }
        
        @media (max-width: 375px) {
            .animation-controls.collapsed {
                padding: 4px 8px;
                border-radius: 20px;
            }
            
            .animation-controls.collapsed .year-display {
                min-width: 38px;
                font-size: 12px;
                padding: 2px 3px;
            }
            
            .animation-controls.collapsed .play-pause-btn {
                margin-right: 2px;
                width: 50px;
            }
        }
        
        /* Mobile styling for animation controls */
        @media (max-width: 768px) {
            .animation-controls {
                bottom: 15px;
                padding: 6px;
                border-radius: 6px;
                width: 85%;
                max-width: 320px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                transition: all 0.3s ease;
            }
            
            .animation-collapse-btn {
                display: flex;
                width: 24px;
                height: 24px;
                font-size: 14px;
                margin-left: 3px;
            }
            
            .animation-controls.visible {
                flex-direction: column;
                align-items: stretch;
                gap: 4px;
            }
            
            .animation-row {
                display: flex;
                align-items: center;
                gap: 4px;
                width: 100%;
                justify-content: space-between;
            }
            
            .animation-primary-row {
                margin-bottom: 2px;
            }
            
            .timeline-slider {
                width: 100%;
                margin: 3px 0;
                height: 28px; /* Better touch target, but compact */
            }
            
            .year-display {
                font-size: 14px;
                font-weight: bold;
                min-width: 50px;
                text-align: center;
                background-color: #f0f0f0;
                border-radius: 4px;
                padding: 3px 6px;
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            }
            
            .play-pause-btn {
                flex: 0 0 auto;
                width: 70px;
                padding: 5px 8px;
                font-size: 13px;
                border-radius: 4px;
                font-weight: bold;
                box-shadow: 0 1px 3px rgba(0,0,0,0.15);
                display: flex;
                justify-content: center;
                align-items: center;
            }
            
            .play-pause-btn:active {
                transform: scale(0.95);
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            }
            
            .speed-control {
                display: flex;
                align-items: center;
                flex: 0 0 auto;
                justify-content: flex-end;
                gap: 3px;
            }
            
            .speed-label {
                font-size: 12px;
            }
            
            .speed-control select {
                padding: 5px 6px;
                border-radius: 4px;
                border: 1px solid #ddd;
                background-color: #f8f8f8;
                width: 70px;
                font-size: 12px;
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                -webkit-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='none' stroke='%23888' viewBox='0 0 12 12'%3E%3Cpath d='M3 5l3 3 3-3'/%3E%3C/svg%3E");
                background-repeat: no-repeat;
                background-position: right 6px center;
                background-size: 8px;
            }
            
            /* Extra small mobile devices */
            @media (max-width: 375px) {
                .animation-controls {
                    bottom: 10px;
                    padding: 5px;
                    width: 95%;
                    max-width: 300px;
                }
                
                .play-pause-btn {
                    width: 60px;
                    padding: 4px 6px;
                    font-size: 12px;
                }
                
                .year-display {
                    min-width: 45px;
                    font-size: 13px;
                    padding: 2px 4px;
                }
                
                .speed-control select {
                    width: 60px;
                    padding: 3px 5px;
                }
                
                .speed-label {
                    font-size: 11px;
                }
                
                .animation-collapse-btn {
                    width: 22px;
                    height: 22px;
                    font-size: 12px;
                }
            }
            
            /* Set default collapsed state for very small screens */
            @media (max-width: 350px) {
                .animation-controls.visible {
                    width: auto;
                    padding: 6px 10px;
                    border-radius: 30px;
                    opacity: 0.85;
                    max-width: min-content;
                    bottom: 5px;
                }
                
                .animation-controls.visible:not(.collapsed) {
                    width: 85%;
                    max-width: 300px;
                    border-radius: 6px;
                    padding: 5px;
                    opacity: 1;
                }
                
                .animation-controls.visible .animation-row:not(.animation-primary-row),
                .animation-controls.visible .timeline-slider,
                .animation-controls.visible .speed-control {
                    display: none;
                }
                
                .animation-controls.visible .animation-collapse-btn {
                    transform: rotate(180deg);
                }
                
                .animation-controls.visible.collapsed .animation-collapse-btn {
                    transform: rotate(180deg);
                }
                
                .animation-controls.visible:not(.collapsed) .animation-collapse-btn {
                    transform: rotate(0deg);
                }
                
                .animation-controls.visible:not(.collapsed) .animation-row:not(.animation-primary-row),
                .animation-controls.visible:not(.collapsed) .timeline-slider,
                .animation-controls.visible:not(.collapsed) .speed-control {
                    display: flex;
                }
            }
        }
        
        /* Desktop styling */
        @media (min-width: 769px) {
            .animation-row {
                display: flex;
                align-items: center;
                gap: 10px;
                width: 100%;
            }
            
            .play-pause-btn {
                min-width: 80px;
            }
            
            .timeline-slider {
                flex-grow: 1;
                margin: 0 10px;
            }
        }
        
        .play-pause-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
        }
        
        .play-pause-btn:hover {
            background: #3e8e41;
        }
        
        .play-pause-btn:active {
            transform: scale(0.98);
        }
        
        .play-pause-btn.playing {
            background-color: #ff9800;
            position: relative;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.5); }
            70% { box-shadow: 0 0 0 6px rgba(255, 152, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 152, 0, 0); }
        }
        
        @media (max-width: 768px) {
            .play-pause-btn.playing::before {
                position: absolute;
                font-size: 10px;
                right: 8px;
                top: 50%;
                transform: translateY(-50%);
            }
        }
        
        .year-display {
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .timeline-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #e0e0e0;
            outline: none;
            border-radius: 3px;
            width: 100%;
            margin: 12px 0;
        }
        
        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .timeline-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        /* Enhanced slider for touch devices */
        @media (pointer: coarse) {
            .timeline-slider {
                height: 12px;
                margin: 18px 0;
            }
            
            .timeline-slider::-webkit-slider-thumb {
                width: 34px;
                height: 34px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                border: 3px solid white;
                transform: scale(1);
                transition: transform 0.2s;
            }
            
            .timeline-slider::-moz-range-thumb {
                width: 34px;
                height: 34px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                border: 3px solid white;
                transform: scale(1);
                transition: transform 0.2s;
            }
            
            .timeline-slider:active::-webkit-slider-thumb {
                transform: scale(1.1);
                background: #3e8e41;
            }
            
            .timeline-slider:active::-moz-range-thumb {
                transform: scale(1.1);
                background: #3e8e41;
            }
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .speed-label {
            font-size: 0.9em;
            color: #666;
        }
        
        .province-boundary {
            stroke: #3388ff;
            stroke-width: 3;
            stroke-opacity: 0.8;
            fill: transparent;
        }
        
        .province-selection {
            margin-top: 15px;
            margin-bottom: 15px;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
        }
        
        .province-selection h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .province-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .province-checkbox input {
            margin-right: 8px;
        }
        
        .province-checkbox label {
            display: inline;
            font-weight: normal;
        }
        
        .province-color {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .leaflet-control-maptype {
            background: white;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            border-radius: 4px;
            z-index: 1000;
        }
        
        .map-type-icon-container {
            display: flex;
            padding-left: 30px;
            width: 100%;
            height: 100%;
        }
        
        .map-type-icon-btn {
            width: 26px;
            height: 26px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            margin: 2px;
            background-size: cover;
            background-position: center;
            transition: all 0.2s ease;
            position: relative;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .map-type-icon-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
        
        .map-type-icon-btn.active {
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.4);
        }
        
        .map-type-label {
            display: block;
            padding: 8px 10px;
            background: #f8f8f8;
            font-size: 12px;
            font-weight: bold;
            border-bottom: 1px solid #e0e0e0;
            color: #555;
            text-align: center;
        }
        
        .map-type-btn {
            display: block;
            width: 100%;
            padding: 8px 10px;
            background: rgb(156, 156, 156);
            border: none;
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
            font-size: 13px;
            text-align: left;
        }
        
        .map-type-btn:last-child {
            border-bottom: none;
        }
        
        .map-type-btn:hover {
            background: #474747;
        }
        
        .map-type-btn.active {
            background: #4CAF50;
            color: white;
        }
        
        .map-type-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 8px;
            background-size: cover;
            vertical-align: middle;
        }
        
        .street-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23555"><path d="M18.1 4.8C18.1 4.3 17.6 4 17 4H13.8C13.4 4 13 4.3 13 4.8V10.2H18.1V4.8M19.3 19.2V10.2H20.9V19.2H19.3M4.8 10.2V19.2H3.1V10.2H4.8M10.2 19.2V13.8H13.8V19.2H10.2M5.9 19.2V13.8H9.1V19.2H5.9M13.8 12.7H10.2V10.2H13.8V12.7M9.1 10.2V12.7H5.9V10.2H9.1M4.8 4.8V9.1H3.1V4.8C3.1 4.3 3.6 4 4.1 4H7.3C7.7 4 8.1 4.3 8.1 4.8V9.1H5.9V4.8H4.8M10.2 9.1V4.8H13V9.1H10.2Z"/></svg>');
        }
        
        .satellite-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23555"><path d="M5,18.31L8.9,15.5L6.81,13.41L5,15.54V18.31M13,15.83L9.5,13.5L13,9.8V15.83M18.04,10.4L20.27,8.17L16.31,4.21L14.08,6.44L18.04,10.4M19.93,11.08L13.8,4.96L10.04,8.72L14,12.68L19.93,11.08M4.23,10.55C4.13,11.23 4.31,11.94 4.76,12.4L10.61,18.24C11.07,18.7 11.78,18.88 12.46,18.77L19.87,17.18L14.3,11.61L8.28,14.73L7.8,14.25C6.97,13.42 6.97,12.08 7.8,11.25L12.57,6.47L8.51,6.13L4.23,10.55Z"/></svg>');
        }
        
        .topo-icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23555"><path d="M22,15.5V17.5H19V21.5H17V17.5H14V21.5H12V17.5H9V21.5H7V17.5H4V15.5H7V11.5H4V9.5H7V5.5H9V9.5H12V5.5H14V9.5H17V5.5H19V9.5H22V11.5H19V15.5H22M17,11.5H14V15.5H17V11.5M12,11.5H9V15.5H12V11.5Z"/></svg>');
        }
        
        .map-controls-panel {
            position: absolute;
            bottom: 20px;
            right: 10px;
            z-index: 1000;
            background: white;
            border-radius: 12px;
            padding: 14px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-height: 500px;
            width: 80%;
            max-width: 300px;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            opacity: 0.97;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .map-controls-panel:hover {
            opacity: 1;
            box-shadow: 0 6px 25px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }
        
        /* Collapsed state */
        .map-controls-panel.collapsed {
            width: 56px;
            max-width: 56px;
            height: 56px;
            max-height: 56px;
            padding: 0;
            border-radius: 50%;
            overflow: hidden;
            background: linear-gradient(145deg, #4CAF50, #2e7d32);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            animation: gentle-pulse 3s infinite alternate;
            backdrop-filter: none;
        }
        
        @keyframes gentle-pulse {
            0% {
                box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            }
            100% {
                box-shadow: 0 4px 20px rgba(76, 175, 80, 0.7);
            }
        }
        
        .map-controls-panel.collapsed:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
            animation-play-state: paused;
        }
        
        .map-controls-panel.collapsed:active {
            transform: scale(0.95);
            transition: transform 0.1s;
        }
        
        .map-controls-panel .scrollable-content {
            overflow-y: auto;
            max-height: calc(100% - 35px); /* Leave room for header */
            padding-right: 5px;
            margin-right: -5px;
            transition: opacity 0.2s ease;
            scrollbar-width: thin;
            scrollbar-color: rgba(76, 175, 80, 0.5) transparent;
        }
        
        /* Style the scrollbar for webkit browsers */
        .map-controls-panel .scrollable-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .map-controls-panel .scrollable-content::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .map-controls-panel .scrollable-content::-webkit-scrollbar-thumb {
            background-color: rgba(76, 175, 80, 0.5);
            border-radius: 6px;
        }
        
        /* Desktop styling for map controls */
        @media (min-width: 992px) {
            .map-controls-panel {
                top: 10px;
                bottom: auto;
                max-height: 80vh; /* 80% of viewport height to ensure it fits on screen */
                width: 300px;
            }
        }
        
        /* Mobile styling for map controls */
        @media (max-width: 768px) {
            .map-controls-panel {
                bottom: 20px;
                right: 10px;
                max-height: 60vh; /* 60% of viewport height for mobile */
                width: calc(100% - 20px); /* Full width minus margins */
                max-width: 300px;
            }
            
            .map-controls-panel .scrollable-content {
                /* Improve touch scrolling on mobile */
                -webkit-overflow-scrolling: touch;
                overflow-y: auto;
                max-height: calc(60vh - 45px); /* Account for header height and padding */
                padding-bottom: 20px; /* Extra padding at bottom for better mobile scrolling */
            }
            
            /* Ensure controls are big enough for touch interaction */
            .control-item {
                min-height: 36px; /* Larger touch target */
                padding: 5px 0;
            }
            
            .opacity-slider {
                height: 15px; /* Thicker slider for easier touch */
            }
            
            .opacity-slider::-webkit-slider-thumb {
                width: 22px;
                height: 22px;
            }
            
            .opacity-slider::-moz-range-thumb {
                width: 22px;
                height: 22px;
            }
        }
        
        .map-controls-header {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            height: 28px;
            cursor: pointer;
            user-select: none;
            color: #2e7d32;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .map-controls-header::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(76, 175, 80, 0.3), transparent);
            transition: opacity 0.3s ease;
        }
        
        .map-controls-header-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: calc(100% - 35px);
            transition: all 0.3s ease;
            position: relative;
            padding-left: 2px;
        }
        
        .map-controls-header-text::before {
            content: '⚙';
            margin-right: 6px;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .map-controls-toggle {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #4CAF50;
            border-radius: 50%;
            transition: all 0.3s ease;
            margin-left: auto;
            background-color: rgba(76, 175, 80, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .map-controls-toggle::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(76, 175, 80, 0.2) 0%, rgba(76, 175, 80, 0) 70%);
            transform: scale(0);
            transition: transform 0.4s ease-out;
            z-index: -1;
        }
        
        /* Icon styles when collapsed */
        .map-controls-panel.collapsed .map-controls-toggle {
            position: absolute;
            top: 0;
            left: 0;
            width: 56px;
            height: 56px;
            color: white;
            background-color: transparent;
            z-index: 10;
        }
        
        .map-controls-panel.collapsed .map-controls-toggle::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            opacity: 0;
            transform: scale(0);
            transition: transform 0.3s, opacity 0.3s;
        }
        
        .map-controls-panel.collapsed .map-controls-toggle:hover::after {
            opacity: 1;
            transform: scale(1);
        }
        
        .map-controls-panel.collapsed .map-controls-header-text,
        .map-controls-panel.collapsed .scrollable-content {
            opacity: 0;
            pointer-events: none;
        }
        
        .map-controls-toggle:hover {
            color: #2e7d32;
            background-color: rgba(76, 175, 80, 0.15);
            transform: translateY(-1px);
        }
        
        .map-controls-toggle:hover::before {
            transform: scale(2);
        }
        
        .map-controls-toggle:active {
            transform: scale(0.9);
            transition: transform 0.1s;
        }
        
        /* Active features indicator */
        .map-controls-panel.collapsed .active-features-indicator {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 12px;
            height: 12px;
            background-color: #ff9800;
            border-radius: 50%;
            border: 2px solid white;
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease;
            z-index: 20;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .map-controls-panel.collapsed.has-active-features .active-features-indicator {
            opacity: 1;
            transform: scale(1);
        }

        
        /* Mini preview when collapsed */
        .map-controls-panel.collapsed::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-image: linear-gradient(45deg, 
                rgba(255,255,255,0.2) 25%, 
                transparent 25%, 
                transparent 50%, 
                rgba(255,255,255,0.2) 50%, 
                rgba(255,255,255,0.2) 75%, 
                transparent 75%, 
                transparent
            );
            background-size: 6px 6px;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.5;
            z-index: 1;
        }
        
        /* Make sliders more visually appealing */
        .opacity-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, rgba(76, 175, 80, 0.2), rgba(76, 175, 80, 0.8));
            outline: none;
            margin: 12px 0 6px 0;
            width: 100%;
        }
        
        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4CAF50;
            border: 2px solid white;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        
        .opacity-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4CAF50;
            border: 2px solid white;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        
        .opacity-slider::-webkit-slider-thumb:hover,
        .opacity-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
        }
        
        .opacity-value {
            text-align: center;
            font-size: 12px;
            color: #666;
            user-select: none;
        }
        
        .map-controls-content {
            opacity: 1;
            transition: opacity 0.3s ease;
            padding-bottom: 10px; /* Add padding at the bottom for better spacing */
            position: relative; /* For positioning the back-to-top button */
        }
        
        /* Back to top button for mobile scrolling */
        .back-to-top {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1010;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            transform: translateY(20px);
            cursor: pointer;
        }
        
        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .back-to-top:active {
            transform: scale(0.95);
        }
        
        .control-section {
            margin-bottom: 16px;
            border-bottom: 1px solid rgba(0,0,0,0.06);
            padding-bottom: 12px;
            transition: all 0.3s ease;
        }
        
        .control-section:hover {
            background-color: rgba(76, 175, 80, 0.05);
            border-radius: 6px;
            padding-left: 5px;
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .control-section-title {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 10px;
            color: #444;
            display: flex;
            align-items: center;
        }
        
        .control-section-title::after {
            content: '';
            flex-grow: 1;
            height: 1px;
            background: rgba(0,0,0,0.06);
            margin-left: 8px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 3px 0;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .control-item:hover {
            background-color: rgba(76, 175, 80, 0.08);
            padding-left: 4px;
        }
        
        .control-item:last-child {
            margin-bottom: 0;
        }
        
        .control-item label {
            margin-left: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        
        .control-item:hover label {
            color: #2e7d32;
        }
        

        
        
        
        /* Loading Screen Styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-top: 20px;
            text-align: center;
        }
        
        .loading-subtext {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
            max-width: 80%;
        }
        
        .color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 5px;
        }
        
        .opacity-slider {
            width: 100%;
            margin-top: 8px;
        }
        
        .opacity-value {
            font-size: 12px;
            text-align: center;
            margin-top: 2px;
        }
        
        /* Add styling for waterways */
        .waterway-path {
            stroke: darkblue;
            stroke-width: 2;
            stroke-opacity: 0.8;
            fill: darkblue;
            fill-opacity: 0.5;
        }
        
        /* Tooltip and Model Details Styles */
        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .model-details-container {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        
        .model-details {
            background-color: #f9f9f9;
            border-radius: 5px;
            padding: 12px;
            border-left: 3px solid #4CAF50;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .model-details h4 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 15px;
        }
        
        .model-details p {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #555;
            line-height: 1.4;
        }
        
        .details-expandable {
            margin-top: 8px;
        }
        
        .expand-button {
            color: #2196F3;
            cursor: pointer;
            font-size: 13px;
            padding: 4px 0;
            user-select: none;
        }
        
        .expand-button:hover {
            text-decoration: underline;
        }
        
        .expanded-content {
            display: none;
            padding-top: 8px;
            animation: expandFadeIn 0.3s ease-in-out;
        }
        
        @keyframes expandFadeIn {
            from { opacity: 0; max-height: 0; }
            to { opacity: 1; max-height: 1000px; }
        }
        
        .expanded-content h5 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #333;
        }
        
        .expanded-content ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .expanded-content li {
            margin-bottom: 5px;
            font-size: 13px;
            color: #555;
        }
        
        .expanded-content ul ul {
            margin-top: 5px;
        }
        
        /* Map Type Control collapsible styles */
        .leaflet-control-maptype {
            background: white;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            border-radius: 4px;
            z-index: 1000;
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .leaflet-control-maptype.collapsed {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            background: white;
            overflow: hidden;
        }
        
        .maptype-toggle-btn {
            position: absolute;
            top: 0;
            left: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            cursor: pointer;
            font-size: 20px;
            color: #555;
            background-color: white;
            transition: all 0.2s ease;
        }
        
        .maptype-toggle-btn:hover {
            background-color: #f4f4f4;
        }
        
        .leaflet-control-maptype.collapsed .map-type-icon-container {
            transform: translateX(100px);
            opacity: 0;
            pointer-events: none;
        }
        
        .leaflet-control-maptype:not(.collapsed) .maptype-toggle-btn {
            background-color: transparent;
        }
        
        .maptype-toggle-btn::before {
            content: '🗺️';
        }
        
        /* Tooltip for collapsed state */
        .maptype-toggle-btn::after {
            content: 'Map Type';
            position: absolute;
            white-space: nowrap;
            right: -5px;
            top: 50%;
            transform: translate(100%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .leaflet-control-maptype.collapsed .maptype-toggle-btn:hover::after {
            opacity: 1;
        }
        
        .map-type-label {
            display: block;
            padding: 8px 10px;
            background: #f8f8f8;
            font-size: 12px;
            font-weight: bold;
            border-bottom: 1px solid #e0e0e0;
            color: #555;
            text-align: center;
        }
        
        /* Leaflet Map Positioning Fixes */
        .leaflet-container {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: 1 !important;
        }
        
        /* Fix for drawing tools when sidebar is collapsed */
        .leaflet-draw.leaflet-control {
            z-index: 1000;
            position: relative;
        }
        
        /* Prevent unwanted scrolling in map container */
        .map-container {
            overflow: hidden;
        }
        
        /* Ensure proper touch handling on mobile */
        @media (max-width: 991px) {
            .leaflet-touch .leaflet-draw-toolbar a {
                height: 34px;
                width: 34px;
                line-height: 34px;
            }
            
            /* Increase touch targets for mobile drawing */
            .leaflet-touch .leaflet-control-layers, 
            .leaflet-touch .leaflet-bar {
                border-width: 2px;
            }
            
            /* Fix position issues when sidebar collapses */
            .sidebar.collapsed ~ .map-container .leaflet-control-container {
                transition: all 0.3s ease;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Processing...</div>
        <div class="loading-subtext" id="loadingSubtext">This may take a few moments</div>
    </div>
    
    
    <div class="container">
        <div class="sidebar">
            <button class="sidebar-toggle">≡</button>
            <h2 style="margin-bottom: 25px; color: #2c3e50; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">Land Area Analysis</h2>
            
            <div class="sidebar-section">
                <h3 class="section-title">Model Selection</h3>
                <div style="display: flex; flex-direction: column; gap: 8px; margin-left: 5px; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center;">
                        <input type="radio" id="ndvi-model" name="model-type" value="ndvi" class="styled-radio" checked>
                        <label for="ndvi-model" class="radio-label">NDVI-based Analysis</label>
                        <span class="tooltip-icon" data-model="ndvi">ℹ️</span>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <input type="radio" id="dynamicworld-model" name="model-type" value="dynamicworld" class="styled-radio">
                        <label for="dynamicworld-model" class="radio-label">Dynamic World V1</label>
                        <span class="tooltip-icon" data-model="dynamicworld">ℹ️</span>
                    </div>
                </div>
                <div class="model-details-container">
                    <div id="ndvi-details" class="model-details">
                        <h4>NDVI (Normalized Difference Vegetation Index)</h4>
                        <p>A numerical indicator that uses the visible and near-infrared bands of the electromagnetic spectrum to analyze remote sensing measurements and assess whether the target contains live green vegetation.</p>
                        <div class="details-expandable">
                            <div class="expand-button">Show more details</div>
                            <div class="expanded-content">
                                <h5>Features:</h5>
                                <ul>
                                    <li><strong>Range:</strong> -1.0 to 1.0</li>
                                    <li><strong>Interpretation:</strong>
                                        <ul>
                                            <li>-1.0 to 0.1: Water/Bare Soil</li>
                                            <li>0.1 to 0.3: Sparse Vegetation</li>
                                            <li>0.3 to 0.6: Moderate Vegetation</li>
                                            <li>0.6 to 1.0: Dense Vegetation</li>
                                        </ul>
                                    </li>
                                    <li><strong>Data Source:</strong> Landsat satellite imagery</li>
                                    <li><strong>Applications:</strong> Vegetation monitoring, crop health assessment, land cover change detection</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div id="dynamicworld-details" class="model-details" style="display: none;">
                        <h4>Dynamic World V1</h4>
                        <p>A near real-time global land cover dataset at 10m resolution produced from Sentinel-2 satellite imagery, using a machine learning model to classify land cover into distinct categories.</p>
                        <div class="details-expandable">
                            <div class="expand-button">Show more details</div>
                            <div class="expanded-content">
                                <h5>Features:</h5>
                                <ul>
                                    <li><strong>Categories:</strong>
                                        <ul>
                                            <li>Water - Rivers, lakes, oceans</li>
                                            <li>Trees - Forested areas</li>
                                            <li>Grass - Grasslands, lawns</li>
                                            <li>Flooded Vegetation - Wetlands</li>
                                            <li>Crops - Agricultural areas</li>
                                            <li>Shrub and Scrub - Shrublands</li>
                                            <li>Built - Urban/developed areas</li>
                                            <li>Bare - Exposed soil, sand, rocks</li>
                                        </ul>
                                    </li>
                                    <li><strong>Data Source:</strong> Sentinel-2 satellite imagery</li>
                                    <li><strong>Resolution:</strong> 10 meters</li>
                                    <li><strong>Applications:</strong> Land use monitoring, environmental protection, urban planning</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="info-message" style="margin-top: 10px;">
                    <i class="info-icon">i</i>
                    <p>The selected model will be used for time series analysis, forecasting, and land cover classification.</p>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3 class="section-title">Time Series Analysis</h3>
                <div class="year-selector">
                    <select id="start-year" class="styled-select">
                        <option value="">Start Year</option>
                    </select>
                    <select id="end-year" class="styled-select">
                        <option value="">End Year</option>
                    </select>
                </div>
                <button id="analyze-time-series-btn" class="primary-btn" disabled>Analyze Time Series</button>
            </div>
            
            <div class="sidebar-section">
                <h3 class="section-title">Forecasting</h3>
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                    <input type="checkbox" id="enable-forecast" class="styled-checkbox">
                    <label for="enable-forecast" class="checkbox-label">Enable Forecast</label>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <select id="forecast-years" disabled class="styled-select">
                        <option value="1">1 Year</option>
                        <option value="2">2 Years</option>
                        <option value="3">3 Years</option>
                        <option value="5">5 Years</option>
                        <option value="10">10 Years</option>
                    </select>
                    <button id="run-forecast-btn" disabled class="secondary-btn">Run Forecast</button>
                </div>
            </div>

            <div class="sidebar-section">
                <h3 class="section-title">Land Cover Classification</h3>
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                    <input type="checkbox" id="enable-land-cover" class="styled-checkbox">
                    <label for="enable-land-cover" class="checkbox-label">Enable Land Cover Analysis</label>
                </div>
                <div id="land-cover-year-container" style="margin-bottom: 12px; display: none;">
                    <label for="land-cover-year" style="margin-bottom: 5px; display: block;">Select Year:</label>
                    <select id="land-cover-year" class="styled-select">
                        <option value="">Select Year</option>
                    </select>
                </div>
                <button id="run-land-cover-btn" disabled class="secondary-btn">Analyze Land Cover</button>
            </div>
            
            <div class="results sidebar-section" id="results">
                <div class="info-message">
                    <i class="info-icon">i</i>
                    <p>Draw a polygon on the map to select an area for analysis.</p>
                </div>
            </div>
            
            <div class="time-series sidebar-section" id="time-series-results" style="display: none;">
                <h3 class="section-title">Time Series Analysis</h3>
                <div class="chart-container">
                    <canvas id="ndviChart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="vegetationChart"></canvas>
                </div>
            </div>
            
            <div class="legend sidebar-section">
                <h3 class="section-title">NDVI Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff0000;"></div>
                    <span>Water/Bare Soil (-1.0 to 0.1)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffff00;"></div>
                    <span>Sparse Vegetation (0.1 to 0.3)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #90ee90;"></div>
                    <span>Moderate Vegetation (0.3 to 0.6)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #008000;"></div>
                    <span>Dense Vegetation (0.6 to 1.0)</span>
                </div>
            </div>
            

            <div class="legend sidebar-section" id="dynamic-world-legend" style="display: none;">
                <h3 class="section-title">Dynamic World V1 Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background: #419bdf;"></div>
                    <span>Water</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #397d49;"></div>
                    <span>Trees</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #88b053;"></div>
                    <span>Grass</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #7a87c6;"></div>
                    <span>Flooded Vegetation</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e49635;"></div>
                    <span>Crops</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #dfc35a;"></div>
                    <span>Shrub and Scrub</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #c4281b;"></div>
                    <span>Built</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #a59b8f;"></div>
                    <span>Bare</span>
                </div>
            </div>
        </div>
        <div class="map-container">
            <div id="map"></div>
            <!-- Map type control will be added by JavaScript -->
            
            <div class="map-controls-panel collapsed" id="mapControlsPanel">
                <div class="active-features-indicator" title="Active map features"></div>
                <div class="map-controls-header">
                    <span class="map-controls-header-text">Map Features</span>
                    <div class="map-controls-toggle" id="mapControlsToggle" title="Expand Map Features">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                            <path fill-rule="evenodd" d="M8 3.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/>
                            <path fill-rule="evenodd" d="M7.646 8.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8 9.707l-1.646 1.647a.5.5 0 0 1-.708-.708l2-2z"/>
                        </svg>
                </div>
                </div>
                <!-- Back to top button for mobile scrolling -->
                <div class="back-to-top" id="backToTop" title="Back to top">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"/>
                    </svg>
                </div>
                <div class="scrollable-content">
                <div class="map-controls-content">
                    <div class="control-section">
                        <div class="control-section-title">Base Map Opacity</div>
                        <input type="range" id="base-map-opacity" class="opacity-slider" min="0" max="100" value="100">
                        <div class="opacity-value" id="base-map-opacity-value">100%</div>
    </div>

                    <div class="control-section">
                        <div class="control-section-title">Province Boundaries</div>
                        <div class="control-item">
                            <input type="checkbox" id="controls-toggle-all-provinces">
                            <label for="controls-toggle-all-provinces">Toggle All</label>
                        </div>
                        <div class="control-item">
                            <input type="checkbox" id="controls-camsur-toggle">
                            <label for="controls-camsur-toggle">Camarines Sur <span class="color-indicator" style="background-color: #3388ff;"></span></label>
                        </div>
                        <div class="control-item">
                            <input type="checkbox" id="controls-albay-toggle">
                            <label for="controls-albay-toggle">Albay <span class="color-indicator" style="background-color: #33cc33;"></span></label>
                        </div>
                        <input type="range" id="province-opacity" class="opacity-slider" min="0" max="100" value="80">
                        <div class="opacity-value" id="province-opacity-value">80%</div>
                    </div>
                    
                    <div class="control-section">
                        <div class="control-section-title">Water Features</div>
                        <div class="control-item">
                            <input type="checkbox" id="waterways-toggle">
                            <label for="waterways-toggle">Waterways <span class="color-indicator" style="background-color: darkblue;"></span></label>
                        </div>
                        <div class="control-item">
                            <input type="checkbox" id="clip-waterways-toggle">
                            <label for="clip-waterways-toggle">Clip to Selected Area</label>
                        </div>
                        <input type="range" id="waterways-opacity" class="opacity-slider" min="0" max="100" value="80">
                        <div class="opacity-value" id="waterways-opacity-value">80%</div>
                    </div>
                    
                    <div class="control-section" id="layer-controls-section">
                        <div class="control-section-title" id="layer-controls-title">NDVI Layer</div>
                        <div class="control-item">
                            <input type="checkbox" id="layer-toggle" checked>
                            <label for="layer-toggle" id="layer-toggle-label">NDVI Overlay</label>
                        </div>
                        <input type="range" id="layer-opacity" class="opacity-slider" min="0" max="100" value="80">
                        <div class="opacity-value" id="layer-opacity-value">80%</div>
                    </div>
                    
                    <div class="control-section">
                        <div class="control-section-title">Analysis Area</div>
                        <div class="control-item">
                            <input type="checkbox" id="area-toggle" checked>
                            <label for="area-toggle">Selected Area</label>
                        </div>
                        <input type="range" id="area-opacity" class="opacity-slider" min="0" max="100" value="80">
                        <div class="opacity-value" id="area-opacity-value">80%</div>
                    </div>
                    </div>
                </div>
            </div>
            <div class="animation-controls" id="animation-controls">
                <div class="animation-row animation-primary-row">
                <button class="play-pause-btn" id="play-pause-btn">Play</button>
                <span class="year-display" id="year-display"></span>
                <div class="speed-control">
                    <span class="speed-label">Speed:</span>
                    <select id="animation-speed">
                        <option value="2000">Slow</option>
                        <option value="1000" selected>Normal</option>
                        <option value="500">Fast</option>
                    </select>
                </div>
                <button class="animation-collapse-btn" id="animation-collapse-btn" title="Collapse controls">↑</button>
                </div>
                <input type="range" class="timeline-slider" id="timeline-slider" min="0" max="100" value="0">
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script>
        // Calculate and set proper viewport height to handle mobile browser chrome
        function setMobileViewportHeight() {
            let vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        
        // Initialize and update on resize
        window.addEventListener('resize', setMobileViewportHeight);
        window.addEventListener('orientationchange', setMobileViewportHeight);
        
        // Mobile responsiveness and loading screen functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial viewport height
            setMobileViewportHeight();
            
            // Handle sidebar toggle - debug implementation
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            const sidebar = document.querySelector('.sidebar');
            
            if (sidebarToggle && sidebar) {
                console.log("Sidebar toggle found:", sidebarToggle);
                console.log("Sidebar found:", sidebar);
                
                // Function to check if we're on mobile and show/hide toggle accordingly
                function updateSidebarToggleVisibility() {
                    // Consider devices with width less than 768px as mobile
                    if (window.innerWidth < 768) {
                        sidebarToggle.style.display = 'block';
                    } else {
                        sidebarToggle.style.display = 'none';
                        // Ensure sidebar is expanded on desktop
                        sidebar.classList.remove('collapsed');
                    }
                }
                
                // Run initially
                updateSidebarToggleVisibility();
                
                // Remove any existing click event listeners
                const newToggle = sidebarToggle.cloneNode(true);
                sidebarToggle.parentNode.replaceChild(newToggle, sidebarToggle);
                
                // Add new event listener
                newToggle.addEventListener('click', function() {
                    console.log("Toggle clicked");
                    sidebar.classList.toggle('collapsed');
                    this.textContent = sidebar.classList.contains('collapsed') ? '≡' : '×';
                    console.log("Sidebar collapsed:", sidebar.classList.contains('collapsed'));
                    
                    // Force map to recalculate its size and fill available space
                    try {
                        if (window.map) {
                            console.log("Invalidating map size");
                            
                            // Add a container resize observer to ensure map reacts to all size changes
                            const mapContainer = document.querySelector('.map-container');
                            
                            // Multiple invalidations to ensure proper rendering
                            // Immediate invalidation
                            window.map.invalidateSize();
                            
                            // After a short delay to allow initial CSS transitions
                            setTimeout(function() {
                                window.map.invalidateSize({animate: true});
                                console.log("Map size invalidated (first pass)");
                                
                                // And again after the full transition completes
                                setTimeout(function() {
                                    window.map.invalidateSize({animate: true});
                                    console.log("Map size invalidated (second pass)");
                                    
                                    // Final invalidation to ensure all map controls and drawing tools are properly positioned
                                    setTimeout(function() {
                                        window.map.invalidateSize(true);
                                        console.log("Map size invalidated (final pass)");
                                    }, 100);
                                }, 300);
                            }, 50);
                        } else {
                            console.warn("Map object not found");
                        }
                    } catch (error) {
                        console.error("Error invalidating map size:", error);
                    }
                });
                
                // Listen for window resize events
                window.addEventListener('resize', updateSidebarToggleVisibility);
            } else {
                console.error("Sidebar toggle elements not found", {
                    sidebarToggle: sidebarToggle,
                    sidebar: sidebar
                });
            }
            
            // Handle map resize when orientation changes or window is resized
            window.addEventListener('resize', function() {
                if (window.map) {
                    // Immediate invalidation
                    window.map.invalidateSize();
                    
                    // Follow-up invalidation after a short delay to ensure all transitions are complete
                    setTimeout(function() {
                        window.map.invalidateSize(true);
                    }, 250);
                }
            });
            
            // Initialize loading screen functions
            // Loading screen timeout protection
            let loadingTimeout = null;
            const MAX_LOADING_TIME = 120000; // 2 minutes maximum loading time
            
            window.showLoading = function(message, subtext) {
                const overlay = document.getElementById('loadingOverlay');
                const textElement = document.getElementById('loadingText');
                const subtextElement = document.getElementById('loadingSubtext');
                
                if (message) {
                    textElement.textContent = message;
                } else {
                    textElement.textContent = 'Processing...';
                }
                
                if (subtext) {
                    subtextElement.textContent = subtext;
                    subtextElement.style.display = 'block';
                } else {
                    subtextElement.textContent = 'This may take a few moments';
                    subtextElement.style.display = 'block';
                }
                
                overlay.classList.add('active');
                
                // Clear any existing timeout
                if (loadingTimeout) {
                    clearTimeout(loadingTimeout);
                }
                
                // Set safety timeout to automatically hide loading after maximum time
                loadingTimeout = setTimeout(function() {
                    console.warn('Loading screen timeout reached. Force hiding loading screen.');
                    hideLoading();
                    alert('The operation is taking longer than expected. It may still be processing in the background.');
                }, MAX_LOADING_TIME);
            };
            
            window.hideLoading = function() {
                const overlay = document.getElementById('loadingOverlay');
                overlay.classList.remove('active');
                
                // Clear any active loading timeout
                if (loadingTimeout) {
                    clearTimeout(loadingTimeout);
                    loadingTimeout = null;
                }
            };
        });
        
        // Initialize model tooltip functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Set up tooltip icon click handlers
            const tooltipIcons = document.querySelectorAll('.tooltip-icon');
            tooltipIcons.forEach(icon => {
                icon.addEventListener('click', function() {
                    const modelType = this.getAttribute('data-model');
                    toggleModelDetails(modelType);
                });
            });
            
            // Set up expand buttons
            const expandButtons = document.querySelectorAll('.expand-button');
            expandButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const expandedContent = this.nextElementSibling;
                    if (expandedContent.style.display === 'block') {
                        expandedContent.style.display = 'none';
                        this.textContent = 'Show more details';
                    } else {
                        expandedContent.style.display = 'block';
                        this.textContent = 'Hide details';
                    }
                });
            });
            
            // Show model details based on which model is selected
            const modelRadios = document.querySelectorAll('input[name="model-type"]');
            modelRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    // Hide all model details first
                    document.querySelectorAll('.model-details').forEach(detail => {
                        detail.style.display = 'none';
                    });
                    
                    // Update UI based on model selection
                    updateLegendVisibility(this.value);
                });
            });
            
            // Function to toggle model details
            function toggleModelDetails(modelType) {
                const allDetails = document.querySelectorAll('.model-details');
                const targetDetails = document.getElementById(`${modelType}-details`);
                
                // Check if the target details are already visible
                const isVisible = targetDetails.style.display !== 'none';
                
                // Hide all details first
                allDetails.forEach(detail => {
                    detail.style.display = 'none';
                });
                
                // Toggle target details visibility
                if (!isVisible) {
                    targetDetails.style.display = 'block';
                }
                
                // Reset all expanded content
                document.querySelectorAll('.expanded-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                // Reset all expand buttons
                document.querySelectorAll('.expand-button').forEach(button => {
                    button.textContent = 'Show more details';
                });
            }
        });

        // Initialize legend visibility
        window.addEventListener('DOMContentLoaded', function() {
            // Set initial legend visibility based on default selected model
            const initialModel = document.querySelector('input[name="model-type"]:checked').value;
            updateLegendVisibility(initialModel);
        });
        
        // Function to update legend visibility and layer controls based on model selection
        function updateLegendVisibility(modelType) {
            // Update legend visibility
            if (modelType === 'ndvi') {
                document.querySelector('.legend:not(#dynamic-world-legend)').style.display = 'block';
                document.getElementById('dynamic-world-legend').style.display = 'none';
                
                // Update layer controls for NDVI
                document.getElementById('layer-controls-title').textContent = 'NDVI Layer';
                document.getElementById('layer-toggle-label').textContent = 'NDVI Overlay';
            } else if (modelType === 'dynamicworld') {
                document.querySelector('.legend:not(#dynamic-world-legend)').style.display = 'none';
                document.getElementById('dynamic-world-legend').style.display = 'block';
                
                // Update layer controls for Dynamic World
                document.getElementById('layer-controls-title').textContent = 'Land Cover Layer';
                document.getElementById('layer-toggle-label').textContent = 'Dynamic World Overlay';
            }
        }
        
        // Initialize map
        const map = L.map('map').setView([13.4500, 123.4500], 11); // Wider view of Bicol region
        
        // Define Bicol region bounds and view
        const BICOL_CENTER = [13.4500, 123.4500];
        const BICOL_ZOOM = 11;
        
        // Function to reset map view to Bicol region
        function resetMapToBicolView() {
            map.setView(BICOL_CENTER, BICOL_ZOOM, {
                animate: true,
                duration: 1
            });
        }
        
        // Add a reset view button
        L.Control.ResetView = L.Control.extend({
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                const button = L.DomUtil.create('a', 'reset-view-btn', container);
                button.innerHTML = '⌂';
                button.title = 'Reset to Bicol Region View';
                button.style.fontSize = '18px';
                button.style.fontWeight = 'bold';
                button.style.textDecoration = 'none';
                button.style.textAlign = 'center';
                button.style.lineHeight = '30px';
                button.href = '#';
                
                L.DomEvent.on(button, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    resetMapToBicolView();
                });
                
                return container;
            },
            onRemove: function(map) {
                // Nothing to do here
            }
        });
        
        L.control.resetView = function(opts) {
            return new L.Control.ResetView(opts);
        };
        
        // Add the reset view control to the map
        L.control.resetView({ position: 'topleft' }).addTo(map);
        
        // Define base maps
        const baseMaps = {
            topo: L.tileLayer('https://tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
            }),
            street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Imagery &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            })
        };
        
        // Add topo map as default
        let currentBaseMap = 'topo';
        baseMaps[currentBaseMap].addTo(map);
        
        // Create Map Type Control for top-left corner
        L.Control.MapTypeControl = L.Control.extend({
            options: {
                position: 'topleft',
                collapsed: true
            },
            
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-control-maptype');
                const iconContainer = L.DomUtil.create('div', 'map-type-icon-container', container);
                
                // Add toggle button
                const toggleBtn = L.DomUtil.create('div', 'maptype-toggle-btn', container);
                
                // Add map type buttons
                const mapTypes = [
                    { type: 'topo', title: 'Topographic Map', icon: 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23555"><path d="M22,15.5V17.5H19V21.5H17V17.5H14V21.5H12V17.5H9V21.5H7V17.5H4V15.5H7V11.5H4V9.5H7V5.5H9V9.5H12V5.5H14V9.5H17V5.5H19V9.5H22V11.5H19V15.5H22M17,11.5H14V15.5H17V11.5M12,11.5H9V15.5H12V11.5Z"/></svg>\')' },
                    { type: 'street', title: 'Street Map', icon: 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23555"><path d="M18.1 4.8C18.1 4.3 17.6 4 17 4H13.8C13.4 4 13 4.3 13 4.8V10.2H18.1V4.8M19.3 19.2V10.2H20.9V19.2H19.3M4.8 10.2V19.2H3.1V10.2H4.8M10.2 19.2V13.8H13.8V19.2H10.2M5.9 19.2V13.8H9.1V19.2H5.9M13.8 12.7H10.2V10.2H13.8V12.7M9.1 10.2V12.7H5.9V10.2H9.1M4.8 4.8V9.1H3.1V4.8C3.1 4.3 3.6 4 4.1 4H7.3C7.7 4 8.1 4.3 8.1 4.8V9.1H5.9V4.8H4.8M10.2 9.1V4.8H13V9.1H10.2Z"/></svg>\')' },
                    { type: 'satellite', title: 'Satellite', icon: 'url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23555"><path d="M5,18.31L8.9,15.5L6.81,13.41L5,15.54V18.31M13,15.83L9.5,13.5L13,9.8V15.83M18.04,10.4L20.27,8.17L16.31,4.21L14.08,6.44L18.04,10.4M19.93,11.08L13.8,4.96L10.04,8.72L14,12.68L19.93,11.08M4.23,10.55C4.13,11.23 4.31,11.94 4.76,12.4L10.61,18.24C11.07,18.7 11.78,18.88 12.46,18.77L19.87,17.18L14.3,11.61L8.28,14.73L7.8,14.25C6.97,13.42 6.97,12.08 7.8,11.25L12.57,6.47L8.51,6.13L4.23,10.55Z"/></svg>\')' }
                ];
                
                // Create buttons for each map type
                mapTypes.forEach(mapType => {
                    const btn = L.DomUtil.create('div', 'map-type-icon-btn', iconContainer);
                    btn.style.backgroundImage = mapType.icon;
                    btn.title = mapType.title;
                    btn.setAttribute('data-map-type', mapType.type);
                    
                    // Set active class for the current map type
                    if (mapType.type === currentBaseMap) {
                        btn.classList.add('active');
                    }
                    
                    // Add click handler
                    L.DomEvent.on(btn, 'click', function() {
                        // Remove active class from all buttons
                        document.querySelectorAll('.map-type-icon-btn').forEach(b => {
                            b.classList.remove('active');
                        });
                        
                        // Add active class to clicked button
                        this.classList.add('active');
                        
                        // Change base map
                        const mapType = this.getAttribute('data-map-type');
                        changeBaseMap(mapType);
                    });
                    
                    // Stop propagation of events
                    L.DomEvent.disableClickPropagation(btn);
                });
                
                // Set initial collapsed state
                if (this.options.collapsed) {
                    container.classList.add('collapsed');
                }
                
                // Add toggle click handler
                L.DomEvent.on(toggleBtn, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    container.classList.toggle('collapsed');
                });
                
                // Prevent map clicks from propagating
                L.DomEvent.disableClickPropagation(container);
                
                return container;
            }
        });
        
        // Initialize MapTypeControl constructor
        L.control.mapTypeControl = function(opts) {
            return new L.Control.MapTypeControl(opts);
        };
        
        // Add the map type control to the map
        L.control.mapTypeControl({ position: 'topleft' }).addTo(map);
        
        // Function to change base map
        function changeBaseMap(mapType) {
            // Remove all base layers
            Object.values(baseMaps).forEach(layer => {
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
            });
            
            // Add selected base layer
            currentBaseMap = mapType;
            const baseMapLayer = baseMaps[mapType];
            
            // Apply current opacity
            const opacity = parseFloat(document.getElementById('base-map-opacity').value) / 100;
            baseMapLayer.setOpacity(opacity);
            
            // Add to map
            map.addLayer(baseMapLayer);
            
            // Ensure map is properly sized
            map.invalidateSize();
        }
        
        // Make map object available globally for proper resizing
        window.map = map;
        
        // Add event handler to fix map after page is fully loaded
        window.addEventListener('load', function() {
            // Final map size invalidation after everything is loaded
            setTimeout(function() {
                if (window.map) {
                    window.map.invalidateSize({animate: true});
                    console.log("Map size invalidated after full page load");
                }
            }, 500);
        });
        
        // Map features panel toggle - enhanced collapse/expand
        document.getElementById('mapControlsToggle').addEventListener('click', function() {
            const panel = document.getElementById('mapControlsPanel');
            panel.classList.toggle('collapsed');
            
            // Update icon based on state
            if (panel.classList.contains('collapsed')) {
                this.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 3.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4a.5.5 0 0 1 .5-.5z"/>
                    <path fill-rule="evenodd" d="M7.646 8.646a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8 9.707l-1.646 1.647a.5.5 0 0 1-.708-.708l2-2z"/>
                </svg>`;
                this.title = "Expand Map Features";
                
                // Add tooltip with active features
                updateActiveFeaturesBadge();
            } else {
                this.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>
                </svg>`;
                this.title = "Collapse Map Features";
                
                // Scroll to top when opening on mobile for better user experience
                const scrollableContent = panel.querySelector('.scrollable-content');
                if (scrollableContent) {
                    scrollableContent.scrollTop = 0;
                }
                
                // On mobile, make sure the panel is fully visible within the viewport
                if (window.innerWidth <= 768) {
                    // Give a small delay to allow CSS transitions to complete
                    setTimeout(() => {
                        // Ensure the panel is visible in the viewport
                        panel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }, 100);
                }
            }
        });
        
        // Function to update the active features badge
        function updateActiveFeaturesBadge() {
            const panel = document.getElementById('mapControlsPanel');
            let activeFeatures = [];
            
            // Check which features are active
            if (document.getElementById('controls-camsur-toggle').checked) activeFeatures.push('Camarines Sur');
            if (document.getElementById('controls-albay-toggle').checked) activeFeatures.push('Albay');
            if (document.getElementById('waterways-toggle').checked) activeFeatures.push('Waterways');
            if (document.getElementById('area-toggle').checked) activeFeatures.push('Selected Area');
            if (document.getElementById('layer-toggle').checked) activeFeatures.push('NDVI Layer');
            
            // Update badge visibility
            if (activeFeatures.length > 0) {
                panel.classList.add('has-active-features');
                const indicator = panel.querySelector('.active-features-indicator');
                indicator.title = 'Active features: ' + activeFeatures.join(', ');
            } else {
                panel.classList.remove('has-active-features');
            }
        }
        
        // Listen for changes on all feature toggles
        document.querySelectorAll('#mapControlsPanel input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateActiveFeaturesBadge);
        });
        
        // Also allow clicking the header to toggle
        document.querySelector('.map-controls-header').addEventListener('click', function(e) {
            // Only trigger if clicking directly on the header, not on the toggle button
            if (!e.target.closest('.map-controls-toggle')) {
                document.getElementById('mapControlsToggle').click();
            }
        });
        
        // Handle back to top button for mobile scrolling
        document.addEventListener('DOMContentLoaded', function() {
            const backToTopBtn = document.getElementById('backToTop');
            const scrollableContent = document.querySelector('.map-controls-panel .scrollable-content');
            
            if (backToTopBtn && scrollableContent) {
                // Show/hide button based on scroll position
                scrollableContent.addEventListener('scroll', function() {
                    if (scrollableContent.scrollTop > 200 && window.innerWidth <= 768) {
                        backToTopBtn.classList.add('visible');
                    } else {
                        backToTopBtn.classList.remove('visible');
                    }
                });
                
                // Scroll to top when clicking the button
                backToTopBtn.addEventListener('click', function() {
                    scrollableContent.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
            }
        });
        
        // Initialize active features badge
        window.addEventListener('load', function() {
            updateActiveFeaturesBadge();
        });
        
        // Base map opacity control
        document.getElementById('base-map-opacity').addEventListener('input', function() {
            const opacity = parseFloat(this.value) / 100;
            baseMaps[currentBaseMap].setOpacity(opacity);
            document.getElementById('base-map-opacity-value').textContent = `${this.value}%`;
        });
        
        // Map type toggle buttons
        document.querySelectorAll('.map-type-btn').forEach(button => {
            button.addEventListener('click', function() {
                // Remove active class from all buttons
                document.querySelectorAll('.map-type-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Add active class to clicked button
                this.classList.add('active');
                
                // Switch base layer
                const mapType = this.getAttribute('data-map-type');
                
                // Remove all base layers
                Object.values(baseMaps).forEach(layer => {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                });
                
                // Add selected base layer
                currentBaseMap = mapType;
                const baseMapLayer = baseMaps[mapType];
                
                // Apply current opacity
                const opacity = parseFloat(document.getElementById('base-map-opacity').value) / 100;
                baseMapLayer.setOpacity(opacity);
                
                // Add to map
                map.addLayer(baseMapLayer);
            });
        });
        
        // Create layers for province boundaries
        const provinceLayers = {
            camsur: {
                layer: new L.LayerGroup(),
                boundary: null,
                color: '#3388ff',
                visible: false
            },
            albay: {
                layer: new L.LayerGroup(),
                boundary: null,
                color: '#33cc33',
                visible: false
            }
        };
        
        // Create waterways layer
        const waterwaysLayer = {
            layer: new L.LayerGroup(),
            features: null,
            clippedFeatures: null,
            color: 'darkblue',
            visible: false,
            clipped: false
        };
        
        // Function to load waterways
        function loadWaterways() {
            fetch('waterways.geojson')
                .then(response => response.json())
                .then(data => {
                    // Get current waterways opacity
                    const opacity = parseFloat(document.getElementById('waterways-opacity').value) / 100;
                    
                    waterwaysLayer.features = L.geoJSON(data, {
                        style: {
                            color: waterwaysLayer.color,
                            weight: 2,
                            opacity: opacity,
                            fillColor: waterwaysLayer.color,
                            fillOpacity: opacity * 0.5
                        }
                    });
                    
                    // Initialize clipped features as null
                    waterwaysLayer.clippedFeatures = null;
                    
                    // If waterways should be visible, add to map
                    updateWaterwaysDisplay();
                })
                .catch(error => {
                    console.error('Error loading waterways GeoJSON:', error);
                });
        }
        
        // Function to update waterways display based on visibility and clipping
        function updateWaterwaysDisplay() {
            // First, clear the layer
            waterwaysLayer.layer.clearLayers();
            
            // Only proceed if waterways are visible
            if (!waterwaysLayer.visible) {
                return;
            }
            
            // If clipping is enabled and we have both clipped features and area
            if (waterwaysLayer.clipped && waterwaysLayer.clippedFeatures && currentCoordinates) {
                waterwaysLayer.layer.addLayer(waterwaysLayer.clippedFeatures);
            } 
            // Otherwise, show all waterways
            else if (waterwaysLayer.features) {
                waterwaysLayer.layer.addLayer(waterwaysLayer.features);
            }
            
            // Make sure layer is on map if visible
            if (waterwaysLayer.visible && !map.hasLayer(waterwaysLayer.layer)) {
                map.addLayer(waterwaysLayer.layer);
            }
        }
        
        // Function to clip waterways to selected area
        function clipWaterways() {
            if (!currentCoordinates) {
                console.error('No area selected for clipping');
                return;
            }
            
            // Show loading message
            const resultsDiv = document.getElementById('results');
            const previousContent = resultsDiv.innerHTML;
            resultsDiv.innerHTML = '<p>Clipping waterways to selected area...</p>';
            
            fetch('/clip_waterways', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: currentCoordinates
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Get current waterways opacity
                    const opacity = parseFloat(document.getElementById('waterways-opacity').value) / 100;
                    
                    // Create new GeoJSON layer with clipped waterways
                    waterwaysLayer.clippedFeatures = L.geoJSON(data.clipped_waterways, {
                        style: {
                            color: waterwaysLayer.color,
                            weight: 2,
                            opacity: opacity,
                            fillColor: waterwaysLayer.color,
                            fillOpacity: opacity * 0.5
                        }
                    });
                    
                    // Update display
                    updateWaterwaysDisplay();
                    
                    // Restore previous content
                    resultsDiv.innerHTML = previousContent;
                } else {
                    resultsDiv.innerHTML = `<p class="error">Error clipping waterways: ${data.error}</p>`;
                    console.error('Error clipping waterways:', data.error);
                }
            })
            .catch(error => {
                resultsDiv.innerHTML = `<p class="error">Error clipping waterways: ${error.message}</p>`;
                console.error('Error clipping waterways:', error);
            });
        }
        
        // Waterways toggle event handler
        document.getElementById('waterways-toggle').addEventListener('change', function() {
            waterwaysLayer.visible = this.checked;
            
            updateWaterwaysDisplay();
            
            if (!this.checked && map.hasLayer(waterwaysLayer.layer)) {
                map.removeLayer(waterwaysLayer.layer);
            }
        });
        
        // Clip waterways toggle event handler
        document.getElementById('clip-waterways-toggle').addEventListener('change', function() {
            waterwaysLayer.clipped = this.checked;
            
            if (this.checked && currentCoordinates) {
                // If we haven't already clipped, do it now
                if (!waterwaysLayer.clippedFeatures) {
                    clipWaterways();
                } else {
                    // Just update the display
                    updateWaterwaysDisplay();
                }
            } else {
                // Just update to show unclipped
                updateWaterwaysDisplay();
            }
        });
        
        // Waterways opacity event handler
        document.getElementById('waterways-opacity').addEventListener('input', function() {
            const opacity = parseFloat(this.value) / 100;
            document.getElementById('waterways-opacity-value').textContent = `${this.value}%`;
            
            // Update style for both regular and clipped features
            if (waterwaysLayer.features) {
                waterwaysLayer.features.setStyle({
                    opacity: opacity,
                    fillOpacity: opacity * 0.5
                });
            }
            
            if (waterwaysLayer.clippedFeatures) {
                waterwaysLayer.clippedFeatures.setStyle({
                    opacity: opacity,
                    fillOpacity: opacity * 0.5
                });
            }
        });
        
        // Toggle all provinces
        document.getElementById('controls-toggle-all-provinces').addEventListener('change', function() {
            const checked = this.checked;
            
            // Update checkboxes in controls panel
            document.getElementById('controls-camsur-toggle').checked = checked;
            document.getElementById('controls-albay-toggle').checked = checked;
            
            // Update map layers
            Object.keys(provinceLayers).forEach(province => {
                provinceLayers[province].visible = checked;
                
                if (checked) {
                    map.addLayer(provinceLayers[province].layer);
                } else {
                    map.removeLayer(provinceLayers[province].layer);
                }
            });
            
            updateMapView();
        });
        
        // Province opacity control
        document.getElementById('province-opacity').addEventListener('input', function() {
            const opacity = parseFloat(this.value) / 100;
            document.getElementById('province-opacity-value').textContent = `${this.value}%`;
            
            // Update province boundary opacity
            Object.keys(provinceLayers).forEach(province => {
                if (provinceLayers[province].boundary) {
                    provinceLayers[province].boundary.setStyle({
                        opacity: opacity,
                        fillOpacity: opacity * 0.2 // Keep fill more transparent
                    });
                }
            });
        });
        
        // Dynamic layer toggle and opacity
        document.getElementById('layer-toggle').addEventListener('change', function() {
            const visible = this.checked;
            
            if (animationState.currentLayer) {
                if (visible) {
                    if (!map.hasLayer(animationState.currentLayer)) {
                        map.addLayer(animationState.currentLayer);
                    }
                } else {
                    if (map.hasLayer(animationState.currentLayer)) {
                        map.removeLayer(animationState.currentLayer);
                    }
                }
            }
            
            if (currentNdviLayer) {
                if (visible) {
                    if (!map.hasLayer(currentNdviLayer)) {
                        map.addLayer(currentNdviLayer);
                    }
                } else {
                    if (map.hasLayer(currentNdviLayer)) {
                        map.removeLayer(currentNdviLayer);
                    }
                }
            }
        });
        
        document.getElementById('layer-opacity').addEventListener('input', function() {
            const opacity = parseFloat(this.value) / 100;
            document.getElementById('layer-opacity-value').textContent = `${this.value}%`;
            
            if (animationState.currentLayer) {
                animationState.currentLayer.setOpacity(opacity);
            }
            
            if (currentNdviLayer) {
                currentNdviLayer.setOpacity(opacity);
            }
        });
        
        // Analysis area toggle and opacity
        document.getElementById('area-toggle').addEventListener('change', function() {
            const visible = this.checked;
            
            if (visible) {
                if (!map.hasLayer(drawnItems)) {
                    map.addLayer(drawnItems);
                }
            } else {
                if (map.hasLayer(drawnItems)) {
                    map.removeLayer(drawnItems);
                }
            }
        });
        
        document.getElementById('area-opacity').addEventListener('input', function() {
            const opacity = parseFloat(this.value) / 100;
            document.getElementById('area-opacity-value').textContent = `${this.value}%`;
            
            drawnItems.eachLayer(function(layer) {
                if (layer.setStyle) {
                    layer.setStyle({
                        fillOpacity: opacity * 0.2,
                        opacity: opacity
                    });
                }
            });
        });
        
        // Function to load province boundaries
        function loadProvinceBoundary(province, filename, color) {
            fetch(filename)
                .then(response => response.json())
                .then(data => {
                    // Get current province opacity
                    const opacity = parseFloat(document.getElementById('province-opacity').value) / 100;
                    
                    // Create boundary with style
                    provinceLayers[province].boundary = L.geoJSON(data, {
                        style: {
                            color: color,
                            weight: 3,
                            opacity: opacity,
                            fillOpacity: opacity * 0.2
                        }
                    });
                    
                    provinceLayers[province].layer.addLayer(provinceLayers[province].boundary);
                    
                    // Only add to map if explicitly set to visible
                    if (provinceLayers[province].visible) {
                        map.addLayer(provinceLayers[province].layer);
                    }
                    
                    // Don't auto-update map view when loading boundaries
                    // Let the user choose when to show boundaries
                })
                .catch(error => {
                    console.error(`Error loading ${province} GeoJSON:`, error);
                });
        }
        
        // Load province boundaries
        loadProvinceBoundary('camsur', 'camsur.geojson', provinceLayers.camsur.color);
        loadProvinceBoundary('albay', 'albay.geojson', provinceLayers.albay.color);
        
        // Only need controls panel event handlers since sidebar province selection is removed
        document.getElementById('controls-camsur-toggle').addEventListener('change', function() {
            provinceLayers.camsur.visible = this.checked;
            
            if (this.checked) {
                map.addLayer(provinceLayers.camsur.layer);
            } else {
                map.removeLayer(provinceLayers.camsur.layer);
            }
            
            updateMapView();
        });
        
        document.getElementById('controls-albay-toggle').addEventListener('change', function() {
            provinceLayers.albay.visible = this.checked;
            
            if (this.checked) {
                map.addLayer(provinceLayers.albay.layer);
            } else {
                map.removeLayer(provinceLayers.albay.layer);
            }
            
            updateMapView();
        });
        
        // Function to update map view based on visible layers
        function updateMapView() {
            const visibleBoundaries = [];
            
            if (provinceLayers.camsur.boundary && provinceLayers.camsur.visible) {
                visibleBoundaries.push(provinceLayers.camsur.boundary);
            }
            
            if (provinceLayers.albay.boundary && provinceLayers.albay.visible) {
                visibleBoundaries.push(provinceLayers.albay.boundary);
            }
            
            if (visibleBoundaries.length > 0) {
                // Create a feature group with all visible boundaries
                const group = L.featureGroup(visibleBoundaries);
                map.fitBounds(group.getBounds());
            } else {
                // If no boundaries are selected, reset to Bicol view
                resetMapToBicolView();
            }
        }
        
        // Initialize draw control
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        const drawControl = new L.Control.Draw({
            draw: {
                marker: false,
                circle: false,
                circlemarker: false,
                rectangle: true,
                polyline: false,
                polygon: {
                    allowIntersection: false,
                    drawError: {
                        color: '#e1e100',
                        message: '<strong>Error:</strong> Polygon edges cannot cross!'
                    },
                    shapeOptions: {
                        color: '#3388ff'
                    }
                }
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);
        
        // Fix rectangle drawing when sidebar is collapsed/expanded
        map.on('draw:drawstart', function(e) {
            // Force map to update its size before drawing starts
            map.invalidateSize({animate: false});
            console.log("Invalidating map size before drawing starts");
        });
        
        // Store the current drawn polygon coordinates
        let currentCoordinates = null;
        let currentNdviLayer = null;
        
        function displayStatistics(statistics) {
            const resultsDiv = document.getElementById('results');
            const basicStats = statistics.basic_stats;
            const areaStats = statistics.area_stats;
            
            let html = `
                <div class="stats-section">
                    <div class="stats-title">Total Area: ${statistics.total_area_hectares} hectares</div>
                    
                    <div class="stats-title">Basic Statistics</div>
                    <div class="stat-item">
                        <span class="stat-label">Mean NDVI:</span>
                        <span class="stat-value">${basicStats.mean_ndvi}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Median NDVI:</span>
                        <span class="stat-value">${basicStats.median_ndvi}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Min NDVI:</span>
                        <span class="stat-value">${basicStats.min_ndvi}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Max NDVI:</span>
                        <span class="stat-value">${basicStats.max_ndvi}</span>
                    </div>
                    
                    <div class="stats-title">Vegetation Distribution</div>
            `;
            
            // Order the vegetation types
            const orderedTypes = [
                'dense_vegetation',
                'moderate_vegetation',
                'sparse_vegetation',
                'water_or_bare'
            ];
            
            // Add vegetation type sections in proper order
            for (const key of orderedTypes) {
                if (areaStats[key]) {
                    const stat = areaStats[key];
                const colorMap = {
                    'water_or_bare': '#ff0000',
                    'sparse_vegetation': '#ffff00',
                    'moderate_vegetation': '#90ee90',
                    'dense_vegetation': '#008000'
                };
                
                html += `
                    <div class="vegetation-type">
                        <div class="vegetation-header">
                            <span class="vegetation-name">${stat.description}</span>
                            <span class="vegetation-area">${stat.area_hectares} ha (${stat.percentage}%)</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${stat.percentage}%; background-color: ${colorMap[key]};"></div>
                        </div>
                    </div>
                `;
                }
            }
            
            resultsDiv.innerHTML = html;
        }
        
        // Function to update button state based on area selection
        function updateAnalyzeButtonState() {
            const analyzeBtn = document.getElementById('analyze-time-series-btn');
            
            if (currentCoordinates) {
                analyzeBtn.disabled = false;
            } else {
                analyzeBtn.disabled = true;
            }
        }
        
        // Initialize button state
        updateAnalyzeButtonState();
        
        // Event handler for when a shape is created
        map.on(L.Draw.Event.CREATED, function(event) {
            const layer = event.layer;
            drawnItems.clearLayers();
            drawnItems.addLayer(layer);
            
            // Get coordinates from the drawn shape
            if (layer instanceof L.Polygon) {
                const latlngs = layer.getLatLngs()[0];
                currentCoordinates = latlngs.map(latlng => [latlng.lng, latlng.lat]);
                
                // Make sure the polygon is closed
                if (currentCoordinates.length > 0 && 
                    (currentCoordinates[0][0] !== currentCoordinates[currentCoordinates.length-1][0] || 
                     currentCoordinates[0][1] !== currentCoordinates[currentCoordinates.length-1][1])) {
                    currentCoordinates.push(currentCoordinates[0]);
                }
                
                document.getElementById('results').innerHTML = '<p>Area selected. Click "Analyze Time Series" to process.</p>';
                updateAnalyzeButtonState();
            } else if (layer instanceof L.Rectangle) {
                const bounds = layer.getBounds();
                const nw = bounds.getNorthWest();
                const ne = bounds.getNorthEast();
                const se = bounds.getSouthEast();
                const sw = bounds.getSouthWest();
                
                currentCoordinates = [
                    [nw.lng, nw.lat],
                    [ne.lng, ne.lat],
                    [se.lng, se.lat],
                    [sw.lng, sw.lat],
                    [nw.lng, nw.lat]  // Close the polygon
                ];
                
                document.getElementById('results').innerHTML = '<p>Area selected. Click "Analyze Time Series" to process.</p>';
                updateAnalyzeButtonState();
            }
            
            // If waterways clipping is enabled, update clipped waterways
            if (waterwaysLayer.clipped) {
                clipWaterways();
            }
        });
        
        // Event handler for when shapes are edited
        map.on(L.Draw.Event.EDITED, function(event) {
            const layers = event.layers;
            layers.eachLayer(function(layer) {
                if (layer instanceof L.Polygon) {
                    const latlngs = layer.getLatLngs()[0];
                    currentCoordinates = latlngs.map(latlng => [latlng.lng, latlng.lat]);
                    
                    // Make sure the polygon is closed
                    if (currentCoordinates.length > 0 && 
                        (currentCoordinates[0][0] !== currentCoordinates[currentCoordinates.length-1][0] || 
                         currentCoordinates[0][1] !== currentCoordinates[currentCoordinates.length-1][1])) {
                        currentCoordinates.push(currentCoordinates[0]);
                    }
                    
                    updateAnalyzeButtonState();
                }
            });
            
            // If waterways clipping is enabled, update clipped waterways
            if (waterwaysLayer.clipped) {
                clipWaterways();
            }
        });
        
        // Event handler for when shapes are deleted
        map.on(L.Draw.Event.DELETED, function() {
            stopAnimation();
            if (animationState.currentLayer) {
                map.removeLayer(animationState.currentLayer);
            }
            document.getElementById('animation-controls').classList.remove('visible');
            
            currentCoordinates = null;
            if (currentNdviLayer) {
                map.removeLayer(currentNdviLayer);
                currentNdviLayer = null;
            }
            document.getElementById('results').innerHTML = '<p>Draw a polygon on the map to select an area for analysis.</p>';
            updateAnalyzeButtonState();
            
            // Reset clipped waterways
            waterwaysLayer.clippedFeatures = null;
            updateWaterwaysDisplay();
        });
        
        // Initialize year selectors
        function initializeYearSelectors() {
            const startYearSelect = document.getElementById('start-year');
            const endYearSelect = document.getElementById('end-year');
            const currentYear = new Date().getFullYear();
            
            // Landsat 8 data available from 2013
            for (let year = 2013; year <= currentYear; year++) {
                startYearSelect.add(new Option(year, year));
                endYearSelect.add(new Option(year, year));
            }
            
            // Set default values to 2019-2024
            startYearSelect.value = 2019;
            endYearSelect.value = 2024;
        }
        
        // Animation state
        let animationState = {
            mapTiles: [],
            currentIndex: 0,
            isPlaying: false,
            animationSpeed: 1000,
            animationInterval: null,
            currentLayer: null
        };
        
        function updateMapLayer(index) {
            try {
                // Remove current layer if it exists
                if (animationState.currentLayer) {
                    map.removeLayer(animationState.currentLayer);
                    animationState.currentLayer = null;
                }
                
                // Validate that we have valid map tiles and the index is within range
                if (!animationState.mapTiles || !animationState.mapTiles.length || index >= animationState.mapTiles.length) {
                    console.error('Invalid map tiles or index out of range', {
                        hasTiles: !!animationState.mapTiles,
                        tileCount: animationState.mapTiles ? animationState.mapTiles.length : 0,
                        requestedIndex: index
                    });
                    return;
                }
                
                const tileData = animationState.mapTiles[index];
                
                // Validate that the tile data has a URL
                if (!tileData || !tileData.tile_url) {
                    console.error('Invalid tile data or missing URL', tileData);
                    return;
                }
                
                // Create and add the new layer
                animationState.currentLayer = L.tileLayer(tileData.tile_url);
                animationState.currentLayer.addTo(map);
                
                // Update UI
                document.getElementById('year-display').textContent = `Year: ${tileData.year}`;
                document.getElementById('timeline-slider').value = index;
                
                // Update the statistics in the sidebar for the current year
                if (tileData.statistics) {
                    displayStatistics(tileData.statistics);
                }
                
                // Highlight the current year in the charts
                highlightCurrentYearInCharts(tileData.year);
            } catch (error) {
                console.error('Error updating map layer:', error);
                // Stop animation if there's an error to prevent continuous errors
                stopAnimation();
            }
        }
        
        function startAnimation() {
            if (animationState.animationInterval) {
                clearInterval(animationState.animationInterval);
            }
            
            animationState.animationInterval = setInterval(() => {
                animationState.currentIndex++;
                if (animationState.currentIndex >= animationState.mapTiles.length) {
                    animationState.currentIndex = 0;
                }
                updateMapLayer(animationState.currentIndex);
            }, animationState.animationSpeed);
        }
        
        function stopAnimation() {
            if (animationState.animationInterval) {
                clearInterval(animationState.animationInterval);
                animationState.animationInterval = null;
            }
        }
        
        function initializeAnimation(mapTiles) {
            if (!mapTiles || mapTiles.length === 0) {
                console.error('No map tiles provided for animation initialization');
                return;
            }
            
            console.log(`Initializing animation with ${mapTiles.length} map tiles`);
            
            // Reset any existing animation state
            stopAnimation();
            
            // Reset the animation state completely
            animationState = {
                mapTiles: mapTiles,
                currentIndex: 0,
                isPlaying: false,
                animationSpeed: 1000,
                animationInterval: null,
                currentLayer: null
            };
            
            const controls = document.getElementById('animation-controls');
            const slider = document.getElementById('timeline-slider');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const collapseBtn = document.getElementById('animation-collapse-btn');
            
            // Reset play/pause button state
            playPauseBtn.textContent = 'Play';
            playPauseBtn.style.backgroundColor = '#4CAF50';
            playPauseBtn.classList.remove('playing');
            
            // Show controls and set up slider
            controls.classList.add('visible');
            slider.max = mapTiles.length - 1;
            slider.value = 0;
            
            // Automatically collapse on very small screens
            if (window.innerWidth <= 350) {
                controls.classList.add('collapsed');
                collapseBtn.textContent = '↓';
                collapseBtn.title = 'Expand controls';
            }
                
            // Initial map display
            updateMapLayer(0);
            
            // Remove any existing event listeners by cloning and replacing elements
            // This prevents duplicate event handlers when re-initializing animations
            
            // Replace collapse button to remove old listeners
            const newCollapseBtn = collapseBtn.cloneNode(true);
            collapseBtn.parentNode.replaceChild(newCollapseBtn, collapseBtn);
            
            // Replace play/pause button to remove old listeners
            const newPlayPauseBtn = playPauseBtn.cloneNode(true);
            playPauseBtn.parentNode.replaceChild(newPlayPauseBtn, playPauseBtn);
            
            // Replace slider to remove old listeners
            const newSlider = slider.cloneNode(true);
            slider.parentNode.replaceChild(newSlider, slider);
            
            // Replace speed selector to remove old listeners
            const speedSelector = document.getElementById('animation-speed');
            const newSpeedSelector = speedSelector.cloneNode(true);
            speedSelector.parentNode.replaceChild(newSpeedSelector, speedSelector);
            
            // Get fresh references to the replaced elements
            const freshCollapseBtn = document.getElementById('animation-collapse-btn');
            const freshPlayPauseBtn = document.getElementById('play-pause-btn');
            const freshSlider = document.getElementById('timeline-slider');
            const freshSpeedSelector = document.getElementById('animation-speed');
            
            // Setup collapse button functionality
            freshCollapseBtn.addEventListener('click', function() {
                controls.classList.toggle('collapsed');
                this.textContent = controls.classList.contains('collapsed') ? '↓' : '↑';
                this.title = controls.classList.contains('collapsed') ? 'Expand controls' : 'Collapse controls';
            });
            
            // Play/Pause button handler
            freshPlayPauseBtn.addEventListener('click', () => {
                animationState.isPlaying = !animationState.isPlaying;
                
                // Update button appearance and text
                if (animationState.isPlaying) {
                    freshPlayPauseBtn.textContent = 'Pause';
                    freshPlayPauseBtn.style.backgroundColor = '#ff9800';
                    freshPlayPauseBtn.classList.add('playing');
                } else {
                    freshPlayPauseBtn.textContent = 'Play';
                    freshPlayPauseBtn.style.backgroundColor = '#4CAF50';
                    freshPlayPauseBtn.classList.remove('playing');
                }
                
                if (animationState.isPlaying) {
                    startAnimation();
                } else {
                    stopAnimation();
                }
            });
            
            // Timeline slider handler
            freshSlider.addEventListener('input', (e) => {
                stopAnimation();
                animationState.currentIndex = parseInt(e.target.value);
                updateMapLayer(animationState.currentIndex);
                animationState.isPlaying = false;
                
                // Update play/pause button appearance
                freshPlayPauseBtn.textContent = 'Play';
                freshPlayPauseBtn.style.backgroundColor = '#4CAF50';
                freshPlayPauseBtn.classList.remove('playing');
            });
            
            // Animation speed handler
            freshSpeedSelector.addEventListener('change', (e) => {
                animationState.animationSpeed = parseInt(e.target.value);
                if (animationState.isPlaying) {
                    stopAnimation();
                    startAnimation();
                }
            });
            
            // Always show animation controls
            controls.classList.add('visible');
        }
        
        let ndviChart = null;
        let vegetationChart = null;
        let forecastData = null;
        
        // Linear regression function for forecasting
        function linearRegression(years, values) {
            const n = years.length;
            
            // Convert years to numeric values for calculation (e.g., 2020 -> 0, 2021 -> 1, etc.)
            const normalizedYears = years.map(y => y - years[0]);
            
            // Calculate means
            const meanX = normalizedYears.reduce((sum, x) => sum + x, 0) / n;
            const meanY = values.reduce((sum, y) => sum + y, 0) / n;
            
            // Calculate coefficients
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < n; i++) {
                numerator += (normalizedYears[i] - meanX) * (values[i] - meanY);
                denominator += Math.pow(normalizedYears[i] - meanX, 2);
            }
            
            const slope = numerator / denominator;
            const intercept = meanY - slope * meanX;
            
            // Calculate R-squared
            const predictions = normalizedYears.map(x => slope * x + intercept);
            const totalSumOfSquares = values.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
            const residualSumOfSquares = values.reduce((sum, y, i) => sum + Math.pow(y - predictions[i], 2), 0);
            const rSquared = 1 - (residualSumOfSquares / totalSumOfSquares);
            
            return {
                slope,
                intercept,
                rSquared,
                predict: function(futureYear) {
                    // Convert future year to normalized value
                    const normalizedYear = futureYear - years[0];
                    return slope * normalizedYear + intercept;
                }
            };
        }
        
        // Function to generate forecast data
        function generateForecast(years, values, numYearsToForecast) {
            const regression = linearRegression(years, values);
            
            const lastYear = years[years.length - 1];
            const forecastYears = [];
            const forecastValues = [];
            
            for (let i = 1; i <= numYearsToForecast; i++) {
                const forecastYear = lastYear + i;
                const forecastValue = regression.predict(forecastYear);
                
                // Ensure forecasted NDVI is within valid range (-1 to 1)
                const boundedValue = Math.max(-1, Math.min(1, forecastValue));
                
                forecastYears.push(forecastYear);
                forecastValues.push(boundedValue);
            }
            
            return {
                years: forecastYears,
                values: forecastValues,
                regression: regression
            };
        }
        
        // Calculate forecasted vegetation distribution based on NDVI ranges
        function calculateVegetationDistribution(ndvi) {
            let distribution = {
                'water_or_bare': 0,
                'sparse_vegetation': 0,
                'moderate_vegetation': 0,
                'dense_vegetation': 0
            };
            
            // Simple classification based on NDVI thresholds
            if (ndvi <= 0.1) {
                distribution.water_or_bare = 100;
            } else if (ndvi <= 0.3) {
                const percentInRange = (ndvi - 0.1) / 0.2; // 0 at NDVI 0.1, 1 at NDVI 0.3
                distribution.water_or_bare = 100 - (percentInRange * 100);
                distribution.sparse_vegetation = percentInRange * 100;
            } else if (ndvi <= 0.6) {
                const percentInRange = (ndvi - 0.3) / 0.3; // 0 at NDVI 0.3, 1 at NDVI 0.6
                distribution.sparse_vegetation = 100 - (percentInRange * 100);
                distribution.moderate_vegetation = percentInRange * 100;
            } else {
                const percentInRange = Math.min(1, (ndvi - 0.6) / 0.4); // 0 at NDVI 0.6, 1 at NDVI 1.0
                distribution.moderate_vegetation = 100 - (percentInRange * 100);
                distribution.dense_vegetation = percentInRange * 100;
            }
            
            // Ensure we don't have negative values due to rounding
            Object.keys(distribution).forEach(key => {
                distribution[key] = Math.max(0, distribution[key]);
            });
            
            // Normalize to ensure total is exactly 100%
            const total = Object.values(distribution).reduce((sum, val) => sum + val, 0);
            if (total !== 0) { // Avoid division by zero
                Object.keys(distribution).forEach(key => {
                    distribution[key] = (distribution[key] / total) * 100;
                });
            }
            
            return distribution;
        }
        
        // Function to update charts with forecast data
        function updateChartsWithForecast(yearlyStats, forecast) {
            // Set up forecasting visualization
            setupForecastContainer();
            
            // Helper function to set up the forecast container
            function setupForecastContainer() {
                // Clear any existing forecast results from the sidebar
                const resultsDiv = document.getElementById('results');
                const existingForecastContainer = document.getElementById('forecast-results-container');
                if (existingForecastContainer) {
                    existingForecastContainer.remove();
                }
                
                // Create a new forecast container
                const forecastContainer = document.createElement('div');
                forecastContainer.id = 'forecast-results-container';
                
                // Add a heading and description to the forecast container
                forecastContainer.innerHTML = `
                    <div class="stats-section">
                        <div class="stats-title">NDVI Forecast</div>
                        <div style="font-size: 13px; margin-bottom: 15px; color: #666;">
                            Forecasting vegetation health trends based on historical NDVI data
                        </div>
                    </div>
                `;
                
                // Clear the results div and add our new container
                resultsDiv.innerHTML = '';
                resultsDiv.appendChild(forecastContainer);
            }
            
            const years = yearlyStats.map(stat => stat.year);
            const meanNdvi = yearlyStats.map(stat => stat.basic_stats.mean_ndvi);
            
            // Use our comprehensive chart reset function
            resetChartCanvases();
            
            // Create NDVI trend chart with forecast
            const ndviCtx = document.getElementById('ndviChart').getContext('2d');
            ndviChart = new Chart(ndviCtx, {
                type: 'line',
                data: {
                    labels: [...years, ...forecast.years],
                    datasets: [
                        {
                            label: 'Historical Mean NDVI',
                            data: [...meanNdvi, ...Array(forecast.years.length).fill(null)],
                            borderColor: '#4CAF50',
                            tension: 0.1,
                            pointBackgroundColor: years.map(() => '#4CAF50'),
                            pointRadius: years.map(() => 3),
                            pointHoverRadius: years.map(() => 6)
                        },
                        {
                            label: `Forecasted NDVI (R² = ${forecast.regression.rSquared.toFixed(3)})`,
                            data: [...Array(years.length).fill(null), ...forecast.values],
                            borderColor: '#FF5722',
                            borderDash: [5, 5],
                            tension: 0.1,
                            pointBackgroundColor: forecast.years.map(() => '#FF5722'),
                            pointRadius: forecast.years.map(() => 4),
                            pointHoverRadius: forecast.years.map(() => 7)
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'NDVI Trend Over Time with Forecast'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'NDVI Value'
                            }
                        }
                    }
                }
            });
            
            // Calculate forecasted vegetation distribution based on NDVI ranges
            const vegetationTypes = ['water_or_bare', 'sparse_vegetation', 'moderate_vegetation', 'dense_vegetation'];
            const forecastVegetation = forecast.values.map(ndvi => calculateVegetationDistribution(ndvi));
            
            // Chart reset already handled above
            
            const vegetationData = vegetationTypes.map(type => ({
                type: type,
                values: yearlyStats.map(stat => stat.area_stats[type].percentage)
            }));
            
            // Transpose the forecast data for charting
            const forecastVegValues = vegetationTypes.map(type => ({
                type: type,
                values: forecastVegetation.map(dist => dist[type])
            }));
            
            const combinedLabels = [...years, ...forecast.years];
            
            const vegetationCtx = document.getElementById('vegetationChart').getContext('2d');
            window.vegetationChart = new Chart(vegetationCtx, {
                type: 'bar',
                data: {
                    labels: combinedLabels,
                    datasets: [
                        // Historical data sets
                        ...vegetationTypes.map((type, index) => ({
                            label: yearlyStats[0].area_stats[type].description + ' (Historical)',
                            data: [...vegetationData[index].values, ...Array(forecast.years.length).fill(null)],
                            backgroundColor: {
                                'water_or_bare': '#ff0000',
                                'sparse_vegetation': '#ffff00',
                                'moderate_vegetation': '#90ee90',
                                'dense_vegetation': '#008000'
                            }[type],
                            stack: 'Historical'
                        })),
                        // Forecast data sets
                        ...vegetationTypes.map((type, index) => ({
                            label: yearlyStats[0].area_stats[type].description + ' (Forecast)',
                            data: [...Array(years.length).fill(null), ...forecastVegValues[index].values],
                            backgroundColor: {
                                'water_or_bare': '#ff9999',
                                'sparse_vegetation': '#ffffaa',
                                'moderate_vegetation': '#c5f7c5',
                                'dense_vegetation': '#99cc99'
                            }[type],
                            stack: 'Forecast',
                            borderWidth: 1,
                            borderColor: '#555'
                        }))
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Vegetation Distribution Over Time with Forecast'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw !== null ? context.raw.toFixed(1) : 0}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Year'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Percentage'
                            }
                        }
                    }
                }
            });
            
            // Add highlight capability back for the actual data
            Chart.register({
                id: 'highlightBar',
                beforeDraw: (chart) => {
                    if (chart.config.type !== 'bar' || 
                        !chart.options.plugins.highlight || 
                        chart.options.plugins.highlight.highlightedIndex === -1) {
                        return;
                    }
                    
                    const index = chart.options.plugins.highlight.highlightedIndex;
                    if (index >= years.length) return; // Don't highlight forecast years
                    
                    const meta = chart.getDatasetMeta(0);
                    if (!meta.data[index]) return;
                    
                    const ctx = chart.ctx;
                    const x = meta.data[index].x;
                    const barWidth = meta.data[index].width * 1.2;
                    
                    // Draw a rectangle highlight behind the bars
                    ctx.save();
                    ctx.globalAlpha = 0.1;
                    ctx.fillStyle = '#FF5722';
                    ctx.fillRect(x - barWidth/2, chart.chartArea.top, barWidth, chart.chartArea.bottom - chart.chartArea.top);
                    ctx.restore();
                    
                    // Draw vertical highlight lines on both sides of the bar group
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(x - barWidth/2, chart.chartArea.top);
                    ctx.lineTo(x - barWidth/2, chart.chartArea.bottom);
                    ctx.moveTo(x + barWidth/2, chart.chartArea.top);
                    ctx.lineTo(x + barWidth/2, chart.chartArea.bottom);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#FF5722';
                    ctx.setLineDash([5, 3]);
                    ctx.stroke();
                    ctx.restore();
                }
            });
            
            // Get current vs forecasted vegetation distribution for comparison
            const currentYear = years[years.length - 1];
            const currentDistribution = {};
            vegetationTypes.forEach((type, index) => {
                currentDistribution[type] = vegetationData[index].values[vegetationData[index].values.length - 1];
            });
            
            const forecastYear = forecast.years[forecast.years.length - 1];
            const forecastDistribution = {};
            vegetationTypes.forEach((type, index) => {
                forecastDistribution[type] = forecastVegValues[index].values[forecastVegValues[index].values.length - 1];
            });
            
            // Calculate changes
            const changes = {};
            vegetationTypes.forEach(type => {
                changes[type] = forecastDistribution[type] - currentDistribution[type];
            });
            
            // Create forecast land cover distributions based on NDVI forecasts
            // Calculate seasonal variation (simplistic approach)
            let seasonalVariation = 0.1; // Default value
            if (yearlyStats.length > 1) {
                const ndviValues = yearlyStats.map(stat => stat.basic_stats.mean_ndvi).filter(val => !isNaN(val));
                if (ndviValues.length > 0) {
                    const maxNdvi = Math.max(...ndviValues);
                    const minNdvi = Math.min(...ndviValues);
                    seasonalVariation = maxNdvi - minNdvi;
                }
            }
            
            // Get current land cover distribution
            const latestYearData = yearlyStats[yearlyStats.length - 1];
            const totalArea = parseFloat(latestYearData.total_area_hectares) || 0;
            
            // Get current land cover as a baseline
            const currentLandCover = analyzeLandCover(yearlyStats);
            if (!currentLandCover) return; // Safety check
            
            // Need to enhance the forecast sensitivity to ensure changes are visible
            // This function will translate NDVI changes to more pronounced land cover changes
            function forecastLandCoverFromNDVI(ndviValue, currentLandCover, totalArea) {
                // Create a copy of the current land cover distribution to modify
                const forecastDistribution = {};
                Object.keys(landCoverClasses).forEach(key => {
                    forecastDistribution[key] = {
                        area_hectares: currentLandCover.landCoverDistribution[key]?.area_hectares || 0,
                        percentage: currentLandCover.landCoverDistribution[key]?.percentage || 0
                    };
                });
                
                // Get baseline NDVI for comparison
                const baselineNDVI = latestYearData.basic_stats.mean_ndvi || 0;
                
                // Calculate NDVI change magnitude (normalized to range -1 to 1)
                const ndviChange = ndviValue - baselineNDVI;
                const changeMagnitude = Math.abs(ndviChange) * 5; // Amplify the effect for visibility
                
                // Apply changes based on NDVI trend direction
                if (ndviChange > 0) {
                    // NDVI increasing: more vegetation, less urban/barren
                    // Increase forest
                    forecastDistribution['forest'].percentage += changeMagnitude * 5;
                    // Increase cropland a bit less
                    forecastDistribution['cropland'].percentage += changeMagnitude * 3;
                    // Increase grassland slightly
                    forecastDistribution['grassland'].percentage += changeMagnitude * 2;
                    // Decrease urban and barren
                    forecastDistribution['urban'].percentage -= changeMagnitude * 4;
                    forecastDistribution['barren'].percentage -= changeMagnitude * 6;
                } else {
                    // NDVI decreasing: less vegetation, more urban/barren
                    // Decrease forest significantly
                    forecastDistribution['forest'].percentage -= changeMagnitude * 5;
                    // Decrease cropland a bit less
                    forecastDistribution['cropland'].percentage -= changeMagnitude * 3;
                    // Decrease grassland slightly
                    forecastDistribution['grassland'].percentage -= changeMagnitude * 2;
                    // Increase urban and barren
                    forecastDistribution['urban'].percentage += changeMagnitude * 4;
                    forecastDistribution['barren'].percentage += changeMagnitude * 6;
                }
                
                // Keep water and wetlands relatively stable but with some small changes
                forecastDistribution['water'].percentage += (Math.random() - 0.5) * changeMagnitude;
                forecastDistribution['wetland'].percentage += (Math.random() - 0.5) * changeMagnitude;
                
                // Ensure all percentages are between 0 and 100
                Object.keys(forecastDistribution).forEach(key => {
                    forecastDistribution[key].percentage = Math.max(0, Math.min(100, forecastDistribution[key].percentage));
                });
                
                // Normalize to ensure sum is 100%
                const totalPercentage = Object.values(forecastDistribution).reduce((sum, item) => sum + item.percentage, 0);
                if (totalPercentage > 0) {
                    const normalizationFactor = 100 / totalPercentage;
                    Object.keys(forecastDistribution).forEach(key => {
                        forecastDistribution[key].percentage *= normalizationFactor;
                        forecastDistribution[key].area_hectares = (forecastDistribution[key].percentage / 100) * totalArea;
                    });
                }
                
                return {
                    landCoverDistribution: forecastDistribution,
                    totalArea: totalArea
                };
            }
            
            // Calculate forecasted land cover for each future year with enhanced sensitivity
            const forecastLandCover = forecast.values.map((ndviValue, index) => {
                // Ensure ndviValue is valid
                const validNdviValue = isNaN(ndviValue) ? 0 : Math.max(-1, Math.min(1, ndviValue));
                
                // Use the new forecast function that creates more pronounced changes
                return forecastLandCoverFromNDVI(validNdviValue, currentLandCover, totalArea);
            });
            
            // Get final forecasted land cover
            const finalForecastLandCover = forecastLandCover[forecastLandCover.length - 1];
            
            // Prepare data for land cover time series visualization
            function prepareLandCoverTimeSeriesData() {
                // This function prepares data for a line chart showing land cover changes over time
                
                // Extract years for x-axis
                const historicalYears = yearlyStats.map(stat => stat.year);
                const allYears = [...historicalYears, ...forecast.years];
                
                // We need to simulate historical land cover data since we don't have actual historical data
                // We'll use the current land cover as a baseline and apply small variations based on NDVI
                const historicalNdvi = yearlyStats.map(stat => stat.basic_stats.mean_ndvi);
                const baselineNDVI = historicalNdvi[historicalNdvi.length - 1];
                
                const historicalLandCover = historicalNdvi.map(ndvi => {
                    const ndviChange = ndvi - baselineNDVI;
                    // Create a simulated historical distribution with less pronounced changes than the forecast
                    // This is just to show a trend; in a real application you would use actual historical data
                    return forecastLandCoverFromNDVI(ndvi, currentLandCover, totalArea);
                });
                
                // Combine historical and forecast data
                const landCoverTimeSeries = {};
                
                // Initialize series for each land cover type
                Object.keys(landCoverClasses).forEach(key => {
                    landCoverTimeSeries[key] = {
                        label: landCoverClasses[key].name,
                        color: landCoverClasses[key].color,
                        historicalData: historicalLandCover.map(lc => lc.landCoverDistribution[key].percentage),
                        forecastData: forecastLandCover.map(lc => lc.landCoverDistribution[key].percentage)
                    };
                });
                
                return {
                    years: allYears,
                    historicalYears: historicalYears,
                    forecastYears: forecast.years,
                    landCoverTimeSeries: landCoverTimeSeries
                };
            }
            
            // Add a forecast section to results
            // Create a new container for the forecast results
            const forecastResultsContainer = document.createElement('div');
            forecastResultsContainer.id = 'forecast-results-container';
            const forecastHtml = `
                <div class="stats-section">
                    <div class="stats-title">NDVI Forecast</div>
                    <div class="stat-item">
                        <span class="stat-label">Linear Regression R²:</span>
                        <span class="stat-value">${forecast.regression.rSquared.toFixed(3)}</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Trend:</span>
                        <span class="stat-value">${forecast.regression.slope > 0 ? 'Increasing' : 'Decreasing'} (${forecast.regression.slope.toFixed(4)} per year)</span>
                    </div>
                    <div class="stats-title">Projected NDVI (${forecast.years[forecast.years.length - 1]})</div>
                    <div class="stat-item">
                        <span class="stat-label">Value:</span>
                        <span class="stat-value">${forecast.values[forecast.values.length-1].toFixed(3)}</span>
                    </div>
                    
                    <div class="stats-title">Vegetation Change (${yearlyStats[yearlyStats.length - 1].year} → ${forecast.years[forecast.years.length - 1]})</div>
                    <div class="vegetation-type">
                        <div class="vegetation-header">
                            <span class="vegetation-name">${yearlyStats[0].area_stats.dense_vegetation.description}</span>
                            <span class="vegetation-area" style="color: ${changes.dense_vegetation >= 0 ? 'green' : 'red'}">
                                ${changes.dense_vegetation >= 0 ? '+' : ''}${changes.dense_vegetation.toFixed(1)}%
                            </span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${forecastDistribution.dense_vegetation}%; background-color: #008000;"></div>
                        </div>
                    </div>
                    <div class="vegetation-type">
                        <div class="vegetation-header">
                            <span class="vegetation-name">${yearlyStats[0].area_stats.moderate_vegetation.description}</span>
                            <span class="vegetation-area" style="color: ${changes.moderate_vegetation >= 0 ? 'green' : 'red'}">
                                ${changes.moderate_vegetation >= 0 ? '+' : ''}${changes.moderate_vegetation.toFixed(1)}%
                            </span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${forecastDistribution.moderate_vegetation}%; background-color: #90ee90;"></div>
                        </div>
                    </div>
                    <div class="vegetation-type">
                        <div class="vegetation-header">
                            <span class="vegetation-name">${yearlyStats[0].area_stats.sparse_vegetation.description}</span>
                            <span class="vegetation-area" style="color: ${changes.sparse_vegetation >= 0 ? 'green' : 'red'}">
                                ${changes.sparse_vegetation >= 0 ? '+' : ''}${changes.sparse_vegetation.toFixed(1)}%
                            </span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${forecastDistribution.sparse_vegetation}%; background-color: #ffff00;"></div>
                        </div>
                    </div>
                    <div class="vegetation-type">
                        <div class="vegetation-header">
                            <span class="vegetation-name">${yearlyStats[0].area_stats.water_or_bare.description}</span>
                            <span class="vegetation-area" style="color: ${changes.water_or_bare >= 0 ? 'green' : 'red'}">
                                ${changes.water_or_bare >= 0 ? '+' : ''}${changes.water_or_bare.toFixed(1)}%
                            </span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${forecastDistribution.water_or_bare}%; background-color: #ff0000;"></div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add forecast content to results container
            forecastResultsContainer.innerHTML = forecastHtml;
            
            // Clear any existing results and add the forecast container
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(forecastResultsContainer);
            
            // Add Land Cover forecast section
            if (finalForecastLandCover) {
                // Create land cover forecast div
                const landCoverForecastDiv = document.createElement('div');
                landCoverForecastDiv.className = 'land-cover-forecast-results';
                landCoverForecastDiv.style.marginTop = '20px';
                landCoverForecastDiv.style.padding = '15px';
                landCoverForecastDiv.style.backgroundColor = '#fff';
                landCoverForecastDiv.style.border = '1px solid #ddd';
                landCoverForecastDiv.style.borderRadius = '5px';
                
                // Append to the forecast container instead of results div directly
                document.getElementById('forecast-results-container').appendChild(landCoverForecastDiv);
                
                // Add a title
                const titleDiv = document.createElement('div');
                titleDiv.className = 'stats-title';
                titleDiv.textContent = `Land Cover Forecast (${forecast.years[forecast.years.length - 1]})`;
                landCoverForecastDiv.appendChild(titleDiv);
                
                // Add a description
                const descDiv = document.createElement('div');
                descDiv.style.fontSize = '13px';
                descDiv.style.marginBottom = '15px';
                descDiv.style.color = '#666';
                descDiv.textContent = 'Projected land cover based on NDVI forecast and current distribution patterns.';
                landCoverForecastDiv.appendChild(descDiv);
                
                // Create comparison section for current vs forecasted
                const comparisonDiv = document.createElement('div');
                comparisonDiv.style.display = 'flex';
                comparisonDiv.style.gap = '10px';
                comparisonDiv.style.flexWrap = 'wrap';
                landCoverForecastDiv.appendChild(comparisonDiv);
                
                // Current land cover chart
                const currentChartContainer = document.createElement('div');
                currentChartContainer.style.flex = '1';
                currentChartContainer.style.minWidth = '300px';
                currentChartContainer.style.height = '300px';
                comparisonDiv.appendChild(currentChartContainer);
                
                const currentCanvas = document.createElement('canvas');
                currentCanvas.id = 'currentLandCoverChart';
                currentChartContainer.appendChild(currentCanvas);
                
                // Forecast land cover chart
                const forecastChartContainer = document.createElement('div');
                forecastChartContainer.style.flex = '1';
                forecastChartContainer.style.minWidth = '300px';
                forecastChartContainer.style.height = '300px';
                comparisonDiv.appendChild(forecastChartContainer);
                
                const forecastCanvas = document.createElement('canvas');
                forecastCanvas.id = 'forecastLandCoverChart';
                forecastChartContainer.appendChild(forecastCanvas);
                
                // Land cover changes section
                const changesDiv = document.createElement('div');
                changesDiv.style.marginTop = '20px';
                landCoverForecastDiv.appendChild(changesDiv);
                
                const changesTitle = document.createElement('div');
                changesTitle.className = 'stats-title';
                changesTitle.textContent = 'Projected Land Cover Changes';
                changesDiv.appendChild(changesTitle);
                
                // Sort land cover types for current and forecast
                const sortedCurrentLandCover = Object.entries(currentLandCover.landCoverDistribution)
                    .map(([key, value]) => ({ 
                        key, 
                        ...value, 
                        name: landCoverClasses[key].name,
                        color: landCoverClasses[key].color,
                        description: landCoverClasses[key].description
                    }))
                    .sort((a, b) => b.percentage - a.percentage);
                
                const sortedForecastLandCover = Object.entries(finalForecastLandCover.landCoverDistribution)
                    .map(([key, value]) => ({ 
                        key, 
                        ...value, 
                        name: landCoverClasses[key].name,
                        color: landCoverClasses[key].color,
                        description: landCoverClasses[key].description
                    }))
                    .sort((a, b) => b.percentage - a.percentage);
                
                // Calculate changes in land cover
                const landCoverChanges = {};
                Object.keys(landCoverClasses).forEach(key => {
                    const currentPercentage = currentLandCover.landCoverDistribution[key]?.percentage || 0;
                    const forecastPercentage = finalForecastLandCover.landCoverDistribution[key]?.percentage || 0;
                    
                    // Ensure all values are valid numbers
                    const validCurrentPercentage = isNaN(currentPercentage) ? 0 : currentPercentage;
                    const validForecastPercentage = isNaN(forecastPercentage) ? 0 : forecastPercentage;
                    const validChange = validForecastPercentage - validCurrentPercentage;
                    
                    landCoverChanges[key] = {
                        key,
                        name: landCoverClasses[key].name,
                        color: landCoverClasses[key].color,
                        currentPercentage: validCurrentPercentage,
                        forecastPercentage: validForecastPercentage,
                        change: validChange
                    };
                });
                
                // Create a table for changes
                const changesTable = document.createElement('table');
                changesTable.style.width = '100%';
                changesTable.style.borderCollapse = 'collapse';
                changesTable.style.marginTop = '10px';
                changesDiv.appendChild(changesTable);
                
                // Table header
                const thead = document.createElement('thead');
                changesTable.appendChild(thead);
                
                const headerRow = document.createElement('tr');
                thead.appendChild(headerRow);
                
                ['Land Cover Type', `Current (${yearlyStats[yearlyStats.length - 1].year})`, `Forecast (${forecast.years[forecast.years.length - 1]})`, 'Change'].forEach(text => {
                    const th = document.createElement('th');
                    th.textContent = text;
                    th.style.padding = '8px';
                    th.style.textAlign = 'left';
                    th.style.borderBottom = '2px solid #ddd';
                    headerRow.appendChild(th);
                });
                
                // Table body
                const tbody = document.createElement('tbody');
                changesTable.appendChild(tbody);
                
                // Sort by absolute change magnitude
                const sortedChanges = Object.values(landCoverChanges)
                    .sort((a, b) => Math.abs(b.change) - Math.abs(a.change));
                
                sortedChanges.forEach(item => {
                    const row = document.createElement('tr');
                    tbody.appendChild(row);
                    
                    // Land cover type column with color
                    const typeCell = document.createElement('td');
                    typeCell.style.padding = '8px';
                    typeCell.style.borderBottom = '1px solid #ddd';
                    typeCell.style.display = 'flex';
                    typeCell.style.alignItems = 'center';
                    row.appendChild(typeCell);
                    
                    const colorBox = document.createElement('span');
                    colorBox.style.display = 'inline-block';
                    colorBox.style.width = '12px';
                    colorBox.style.height = '12px';
                    colorBox.style.backgroundColor = item.color;
                    colorBox.style.marginRight = '8px';
                    colorBox.style.borderRadius = '2px';
                    typeCell.appendChild(colorBox);
                    
                    const typeName = document.createElement('span');
                    typeName.textContent = item.name;
                    typeCell.appendChild(typeName);
                    
                    // Current percentage
                    const currentCell = document.createElement('td');
                    currentCell.textContent = `${item.currentPercentage.toFixed(1)}%`;
                    currentCell.style.padding = '8px';
                    currentCell.style.borderBottom = '1px solid #ddd';
                    row.appendChild(currentCell);
                    
                    // Forecast percentage
                    const forecastCell = document.createElement('td');
                    forecastCell.textContent = `${item.forecastPercentage.toFixed(1)}%`;
                    forecastCell.style.padding = '8px';
                    forecastCell.style.borderBottom = '1px solid #ddd';
                    row.appendChild(forecastCell);
                    
                    // Change
                    const changeCell = document.createElement('td');
                    changeCell.textContent = `${item.change >= 0 ? '+' : ''}${item.change.toFixed(1)}%`;
                    changeCell.style.padding = '8px';
                    changeCell.style.color = item.change >= 0 ? 'green' : 'red';
                    changeCell.style.fontWeight = 'bold';
                    changeCell.style.borderBottom = '1px solid #ddd';
                    row.appendChild(changeCell);
                });
                
                // Add the land cover forecast div to results
                resultsDiv.appendChild(landCoverForecastDiv);
                
                // Create the current land cover pie chart
                const currentCtx = document.getElementById('currentLandCoverChart').getContext('2d');
                new Chart(currentCtx, {
                    type: 'pie',
                    data: {
                        labels: sortedCurrentLandCover.map(lc => lc.name),
                        datasets: [{
                            data: sortedCurrentLandCover.map(lc => lc.percentage),
                            backgroundColor: sortedCurrentLandCover.map(lc => lc.color),
                            borderColor: '#fff',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    boxWidth: 12,
                                    padding: 15,
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: `Current Land Cover (${yearlyStats[yearlyStats.length - 1].year})`
                            }
                        }
                    }
                });
                
                // Create the forecast land cover pie chart
                const forecastCtx = document.getElementById('forecastLandCoverChart').getContext('2d');
                new Chart(forecastCtx, {
                    type: 'pie',
                    data: {
                        labels: sortedForecastLandCover.map(lc => lc.name),
                        datasets: [{
                            data: sortedForecastLandCover.map(lc => lc.percentage),
                            backgroundColor: sortedForecastLandCover.map(lc => lc.color),
                            borderColor: '#fff',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    boxWidth: 12,
                                    padding: 15,
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: `Forecasted Land Cover (${forecast.years[forecast.years.length - 1]})`
                            }
                        }
                    }
                });
                
                // Add time series chart for land cover changes
                const timeSeriesContainer = document.createElement('div');
                timeSeriesContainer.style.marginTop = '30px';
                landCoverForecastDiv.appendChild(timeSeriesContainer);
                
                const timeSeriesTitle = document.createElement('div');
                timeSeriesTitle.className = 'stats-title';
                timeSeriesTitle.textContent = 'Land Cover Changes Over Time';
                timeSeriesContainer.appendChild(timeSeriesTitle);
                
                const timeSeriesDescription = document.createElement('div');
                timeSeriesDescription.style.fontSize = '13px';
                timeSeriesDescription.style.marginBottom = '15px';
                timeSeriesDescription.style.color = '#666';
                timeSeriesDescription.textContent = 'Trends and projections of land cover changes over the time period.';
                timeSeriesContainer.appendChild(timeSeriesDescription);
                
                const chartContainer = document.createElement('div');
                chartContainer.style.height = '400px';
                timeSeriesContainer.appendChild(chartContainer);
                
                const canvas = document.createElement('canvas');
                canvas.id = 'landCoverTimeSeriesChart';
                chartContainer.appendChild(canvas);
                
                // Get time series data
                const timeSeriesData = prepareLandCoverTimeSeriesData();
                
                // Create datasets for the chart - show top 5 most significant land cover types
                const significantLandCoverTypes = sortedChanges
                    .filter(item => Math.abs(item.change) > 0.1) // Only include types with meaningful changes
                    .slice(0, 5) // Limit to top 5 for clarity
                    .map(item => item.key);
                
                // If we have fewer than 2 significant types, include the top 2 by current percentage
                if (significantLandCoverTypes.length < 2) {
                    const topByPercentage = sortedCurrentLandCover
                        .filter(item => !significantLandCoverTypes.includes(item.key))
                        .slice(0, 2)
                        .map(item => item.key);
                    
                    significantLandCoverTypes.push(...topByPercentage);
                }
                
                // Prepare datasets for the line chart
                const datasets = significantLandCoverTypes.map(key => {
                    const series = timeSeriesData.landCoverTimeSeries[key];
                    return [
                        // Historical data
                        {
                            label: `${series.label} (Historical)`,
                            data: series.historicalData,
                            borderColor: series.color,
                            backgroundColor: series.color + '20', // Add transparency
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.1
                        },
                        // Forecast data with dashed line
                        {
                            label: `${series.label} (Forecast)`,
                            data: Array(timeSeriesData.historicalYears.length).fill(null).concat(series.forecastData),
                            borderColor: series.color,
                            borderDash: [5, 5],
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            tension: 0.1
                        }
                    ];
                }).flat();
                
                // Create the line chart
                const timeSeriesCtx = document.getElementById('landCoverTimeSeriesChart').getContext('2d');
                new Chart(timeSeriesCtx, {
                    type: 'line',
                    data: {
                        labels: timeSeriesData.years,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Land Cover Changes Over Time'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.raw !== null ? context.raw.toFixed(1) : 0}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Percentage of Total Area'
                                },
                                min: 0,
                                max: 100
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Year'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        function createTimeSeriesCharts(yearlyStats) {
            console.log('Initializing NDVI time series visualization');
            
            // Reset all chart canvases first to prevent any chart conflicts
            resetChartCanvases();
            
            // Make sure the time series container is visible
            const timeSeriesContainer = document.getElementById('time-series-results');
            if (timeSeriesContainer) {
                timeSeriesContainer.style.display = 'block';
                console.log('Showing time series container');
            }
            
            const years = yearlyStats.map(stat => stat.year);
            const meanNdvi = yearlyStats.map(stat => stat.basic_stats.mean_ndvi);
            const vegetationTypes = ['water_or_bare', 'sparse_vegetation', 'moderate_vegetation', 'dense_vegetation'];
            
            // Save yearly stats for potential forecasting
            window.yearlyStatsData = yearlyStats;
            
            try {
                console.log('Creating NDVI chart with', years.length, 'data points');
            // Create NDVI trend chart
                const ndviCanvas = document.getElementById('ndviChart');
                const ndviCtx = ndviCanvas.getContext('2d');
                
                window.ndviChart = new Chart(ndviCtx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: [{
                        label: 'Mean NDVI',
                        data: meanNdvi,
                        borderColor: '#4CAF50',
                        tension: 0.1,
                        pointBackgroundColor: years.map(() => '#4CAF50'),
                        pointRadius: years.map(() => 3),
                        pointHoverRadius: years.map(() => 6)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'NDVI Trend Over Time'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'NDVI Value'
                            }
                        }
                    }
                }
            });
                console.log('NDVI chart created successfully');
            } catch (error) {
                console.error('Error creating NDVI chart:', error);
            }
            
            try {
                console.log('Creating vegetation distribution chart');
            // Create vegetation distribution chart
            const vegetationData = vegetationTypes.map(type => ({
                type: type,
                values: yearlyStats.map(stat => stat.area_stats[type].percentage)
            }));
            
                const vegetationCanvas = document.getElementById('vegetationChart');
                const vegetationCtx = vegetationCanvas.getContext('2d');
                
                window.vegetationChart = new Chart(vegetationCtx, {
                type: 'bar',
                data: {
                    labels: years,
                    datasets: vegetationTypes.map((type, index) => ({
                        label: yearlyStats[0].area_stats[type].description,
                        data: vegetationData[index].values,
                        backgroundColor: {
                            'water_or_bare': '#ff0000',
                            'sparse_vegetation': '#ffff00',
                            'moderate_vegetation': '#90ee90',
                            'dense_vegetation': '#008000'
                        }[type]
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Vegetation Distribution Over Time'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Year'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Percentage'
                            }
                        }
                    }
                }
            });
                console.log('Vegetation chart created successfully');
            } catch (error) {
                console.error('Error creating vegetation chart:', error);
            }
        }
        
        function highlightCurrentYearInCharts(year) {
            if (!window.ndviChart || !window.vegetationChart) return;
            
            // Find the index of the current year in the charts
            const yearIndex = window.ndviChart.data.labels.findIndex(y => y == year);
            if (yearIndex === -1) return;
            
            // Reset all point styles for NDVI chart
            window.ndviChart.data.datasets[0].pointBackgroundColor = window.ndviChart.data.labels.map(() => '#4CAF50');
            window.ndviChart.data.datasets[0].pointRadius = window.ndviChart.data.labels.map(() => 3);
            window.ndviChart.data.datasets[0].pointBorderWidth = window.ndviChart.data.labels.map(() => 1);
            
            // Highlight the current year's point
            window.ndviChart.data.datasets[0].pointBackgroundColor[yearIndex] = '#FF5722';
            window.ndviChart.data.datasets[0].pointRadius[yearIndex] = 8;
            window.ndviChart.data.datasets[0].pointBorderWidth[yearIndex] = 2;
            
            // Update the NDVI chart
            window.ndviChart.update();
            
            // Reset all bar styles for vegetation chart
            window.vegetationChart.data.datasets.forEach(dataset => {
                // Set default border width and color for all bars
                if (!dataset._originalBackgroundColor) {
                    dataset._originalBackgroundColor = dataset.backgroundColor;
                }
                
                // Reset background colors and borders
                dataset.backgroundColor = dataset._originalBackgroundColor;
                dataset.borderColor = '#00000000'; // transparent
                dataset.borderWidth = 0;
            });
            
            // Highlight current year's bars in vegetation chart
            window.vegetationChart.data.datasets.forEach(dataset => {
                // Apply highlight styles only to the bars of the current year
                if (Array.isArray(dataset.backgroundColor)) {
                    // For array-style backgroundColor
                    dataset.borderColor = dataset.borderColor || [];
                    dataset.borderWidth = dataset.borderWidth || [];
                    
                    dataset.borderColor[yearIndex] = '#FF5722';
                    dataset.borderWidth[yearIndex] = 2;
                } else {
                    // For non-array backgroundColor, create arrays
                    const colors = [];
                    const borders = [];
                    const widths = [];
                    
                    for (let i = 0; i < window.vegetationChart.data.labels.length; i++) {
                        colors.push(i === yearIndex ? dataset.backgroundColor : dataset.backgroundColor);
                        borders.push(i === yearIndex ? '#FF5722' : '#00000000');
                        widths.push(i === yearIndex ? 2 : 0);
                    }
                    
                    dataset.backgroundColor = colors;
                    dataset.borderColor = borders;
                    dataset.borderWidth = widths;
                }
            });
            
            // Update the vegetation chart
            window.vegetationChart.update();
            
            // Create a highlight plugin for the vegetation chart if it doesn't exist
            if (!window.vegetationChart.options.plugins.highlight) {
                window.vegetationChart.options.plugins.highlight = {
                    highlightedIndex: -1
                };
            }
            
            // Set the highlighted index
            window.vegetationChart.options.plugins.highlight.highlightedIndex = yearIndex;
            
            // Update the vegetation chart again
            window.vegetationChart.update();
                }
        
        // Register a custom plugin for Chart.js to highlight bars
        Chart.register({
            id: 'highlightBar',
            beforeDraw: (chart) => {
                if (chart.config.type !== 'bar' || 
                    !chart.options.plugins.highlight || 
                    chart.options.plugins.highlight.highlightedIndex === -1) {
                    return;
                }
                
                const index = chart.options.plugins.highlight.highlightedIndex;
                const meta = chart.getDatasetMeta(0);
                if (!meta.data[index]) return;
                
                const ctx = chart.ctx;
                const x = meta.data[index].x;
                const barWidth = meta.data[index].width * 1.2; // slightly wider than the bar for better visibility
                
                // Draw a rectangle highlight behind the bars
                ctx.save();
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(x - barWidth/2, chart.chartArea.top, barWidth, chart.chartArea.bottom - chart.chartArea.top);
                ctx.restore();
            
                // Draw vertical highlight lines on both sides of the bar group
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(x - barWidth/2, chart.chartArea.top);
                ctx.lineTo(x - barWidth/2, chart.chartArea.bottom);
                ctx.moveTo(x + barWidth/2, chart.chartArea.top);
                ctx.lineTo(x + barWidth/2, chart.chartArea.bottom);
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#FF5722';
                ctx.setLineDash([5, 3]);
                ctx.stroke();
                ctx.restore();
                }
            });
        
        // Modify the time series analysis handler
        document.getElementById('analyze-time-series-btn').addEventListener('click', function() {
            if (!currentCoordinates) {
                document.getElementById('results').innerHTML = '<p class="error">Please draw an area on the map first.</p>';
                return;
            }

            const startYear = document.getElementById('start-year').value;
            const endYear = document.getElementById('end-year').value;
            
            if (!startYear || !endYear) {
                document.getElementById('results').innerHTML = '<p class="error">Please select start and end years.</p>';
                return;
            }

            // Show loading screen
            showLoading('Analyzing Time Series', `Processing data from ${startYear} to ${endYear}. This may take a while...`);

            // Clear all map layers for a fresh analysis
            clearAllMapLayers();

            document.getElementById('results').innerHTML = '<p>Processing time series... Please wait.</p>';
            document.getElementById('time-series-results').style.display = 'none';
            
            // Get the model type from the global selection
            const modelType = document.querySelector('input[name="model-type"]:checked').value;
            const isAnalyzingDynamicWorld = modelType === 'dynamicworld';
            
            if (isAnalyzingDynamicWorld) {
                // Process Dynamic World time series
                getDynamicWorldTimeSeries(currentCoordinates, parseInt(startYear), parseInt(endYear))
                    .then(result => {
                        if (result.timeseriesData.length > 0) {
                            // Save the data for potential forecasting
                            window.dynamicWorldTimeseriesData = result.timeseriesData;
                            displayDynamicWorldTimeSeries(result.timeseriesData, result.mapTiles);
                            document.getElementById('results').innerHTML = '<p>Dynamic World time series analysis complete!</p>';
                            // Hide loading screen
                            hideLoading();
                        } else {
                            document.getElementById('results').innerHTML = '<p class="error">No Dynamic World data found for the selected time range.</p>';
                            // Hide loading screen
                            hideLoading();
                        }
                    })
                    .catch(error => {
                        document.getElementById('results').innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        // Hide loading screen on error
                        hideLoading();
                    });
            } else {
                // Process NDVI time series (default)
            fetch('/get_yearly_stats', {
                    method: 'POST',
                    headers: {
                    'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                    coordinates: currentCoordinates,
                    start_year: parseInt(startYear),
                    end_year: parseInt(endYear)
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('time-series-results').style.display = 'block';
                    createTimeSeriesCharts(data.yearly_stats);
                    
                    // Initialize animation with map tiles
                    if (data.map_tiles && data.map_tiles.length > 0) {
                        // Merge yearly_stats with map_tiles to include statistics for each year
                        data.map_tiles.forEach((tile, index) => {
                            const matchingStat = data.yearly_stats.find(stat => stat.year == tile.year);
                            if (matchingStat) {
                                tile.statistics = {
                                    total_area_hectares: matchingStat.total_area_hectares,
                                    basic_stats: matchingStat.basic_stats,
                                    area_stats: matchingStat.area_stats
                                };
                            }
                        });
                        
                        initializeAnimation(data.map_tiles);
                        // Display initial statistics
                        if (data.map_tiles[0].statistics) {
                            displayStatistics(data.map_tiles[0].statistics);
                    }
                    }
                    
                        document.getElementById('results').innerHTML = '<p>NDVI time series analysis complete!</p>';
                        // Hide loading screen
                        hideLoading();
                } else {
                    document.getElementById('results').innerHTML = `<p class="error">Error: ${data.error}</p>`;
                    // Hide loading screen
                    hideLoading();
                }
            })
            .catch(error => {
                document.getElementById('results').innerHTML = `<p class="error">Error: ${error.message}</p>`;
                // Hide loading screen on error
                hideLoading();
            });
            }
        });
        
        // Clean up animation when tab is cleared
        map.on(L.Draw.Event.DELETED, function() {
                    stopAnimation();
                    if (animationState.currentLayer) {
                        map.removeLayer(animationState.currentLayer);
                    }
                    document.getElementById('animation-controls').classList.remove('visible');
            
            currentCoordinates = null;
            if (currentNdviLayer) {
                map.removeLayer(currentNdviLayer);
                currentNdviLayer = null;
            }
            document.getElementById('results').innerHTML = '<p>Draw a polygon on the map to select an area for analysis.</p>';
            updateAnalyzeButtonState();
            
            // Reset clipped waterways
            waterwaysLayer.clippedFeatures = null;
            updateWaterwaysDisplay();
        });
        
        // Initialize year selectors when the page loads
        initializeYearSelectors();
        
        // Add event listener for model type change
        document.querySelectorAll('input[name="model-type"]').forEach(radio => {
            radio.addEventListener('change', function() {
                console.log('Model type changed to:', this.value);
                
                // Reset chart canvases immediately when model type changes
                resetChartCanvases();
                
                // Also clear any forecast results
                const existingForecastContainer = document.getElementById('forecast-results-container');
                if (existingForecastContainer) {
                    existingForecastContainer.remove();
                }
                
                const modelType = this.value;
                // Update legends visibility
                if (modelType === 'ndvi') {
                    document.querySelector('.legend:not(#dynamic-world-legend)').style.display = 'block';
                    document.getElementById('dynamic-world-legend').style.display = 'none';
                } else if (modelType === 'dynamicworld') {
                    document.querySelector('.legend:not(#dynamic-world-legend)').style.display = 'none';
                    document.getElementById('dynamic-world-legend').style.display = 'block';
                }
            });
        });
        
        // Handle forecast UI controls
        document.getElementById('enable-forecast').addEventListener('change', function() {
            const forecastYearsSelect = document.getElementById('forecast-years');
            const runForecastBtn = document.getElementById('run-forecast-btn');
            
            forecastYearsSelect.disabled = !this.checked;
            runForecastBtn.disabled = !this.checked;
        });
        
        // Run forecast button handler
        document.getElementById('run-forecast-btn').addEventListener('click', function() {
            const modelType = document.querySelector('input[name="model-type"]:checked').value;
            
            // Show loading screen for forecasting
            showLoading('Generating Forecast', 'Calculating future patterns based on historical data...');
            
            if (modelType === 'ndvi') {
                // Run NDVI forecast
                if (!window.yearlyStatsData || window.yearlyStatsData.length < 2) {
                    alert('Need time series data to create a forecast. Please run the time series analysis with NDVI first.');
                    hideLoading(); // Hide loading when no data is available
                    return;
                }
                
                try {
                    const forecastYears = parseInt(document.getElementById('forecast-years').value);
                    const yearlyStats = window.yearlyStatsData;
                    const years = yearlyStats.map(stat => stat.year);
                    const meanNdvi = yearlyStats.map(stat => stat.basic_stats.mean_ndvi);
                    
                    console.log('Generating NDVI forecast with years:', yearlyStats.length, 'forecast years:', forecastYears);
                    
                    // Generate the forecast using linear regression
                    const forecast = generateForecast(years, meanNdvi, forecastYears);
                    
                    // Update the charts with the forecast data
                    updateChartsWithForecast(yearlyStats, forecast);
                    
                    console.log('NDVI forecast completed successfully');
                    // Hide loading screen after forecast is complete
                    hideLoading();
                } catch (error) {
                    console.error('Error in NDVI forecast generation:', error);
                    alert('Error generating forecast: ' + error.message);
                    // Hide loading screen on error
                    hideLoading();
                }
            } else if (modelType === 'dynamicworld') {
                // Run Dynamic World forecast
                if (!window.dynamicWorldTimeseriesData || window.dynamicWorldTimeseriesData.length < 2) {
                    alert('Need Dynamic World time series data to create a forecast. Please run the time series analysis with Dynamic World first.');
                    hideLoading(); // Add this to hide loading when no data is available
                    return;
                }
                
                const forecastYears = parseInt(document.getElementById('forecast-years').value);
                const dynamicWorldTimeseries = window.dynamicWorldTimeseriesData;
                
                try {
                    console.log('Generating Dynamic World forecast with years:', dynamicWorldTimeseries.length, 'forecast years:', forecastYears);
                    
                    // Generate and display Dynamic World forecast
                    generateDynamicWorldForecast(dynamicWorldTimeseries, forecastYears);
                    console.log('Dynamic World forecast completed successfully');
                    // Hide loading screen after forecast is complete
                    hideLoading();
                } catch (error) {
                    console.error('Error in Dynamic World forecast generation:', error);
                    alert('Error generating forecast: ' + error.message);
                    // Hide loading screen on error
                    hideLoading();
                }
            }
        });
        
        // Save area button click handler
        document.getElementById('save-area-btn').addEventListener('click', function() {
            // Show loading screen
            showLoading('Saving Selected Area', 'Processing and storing your selected area...');
            if (!currentCoordinates) {
                document.getElementById('results').innerHTML = '<p class="error">Please draw an area on the map first.</p>';
                return;
            }
            
            // Send request to server
            fetch('/save_area', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: currentCoordinates
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('results').innerHTML = '<p>Area saved successfully!</p>';
                    // Hide loading screen
                    hideLoading();
                } else {
                    document.getElementById('results').innerHTML = `<p class="error">Error: ${data.error}</p>`;
                    // Hide loading screen
                    hideLoading();
                }
            })
            .catch(error => {
                document.getElementById('results').innerHTML = `<p class="error">Error: ${error.message}</p>`;
                // Hide loading screen on error
                hideLoading();
            });
        });
        
        // Load waterways
        loadWaterways();

        // Landcover classification and analysis
        const landCoverClasses = {
            water: {
                name: "Water Bodies",
                color: "#0066ff",
                description: "Rivers, lakes, ponds, and other water features"
            },
            urban: {
                name: "Urban/Built-up",
                color: "#ff0000",
                description: "Buildings, roads, and other human infrastructure"
            },
            barren: {
                name: "Barren Land",
                color: "#cccccc",
                description: "Exposed soil, sand, rocks with minimal vegetation"
            },
            cropland: {
                name: "Agriculture/Cropland",
                color: "#ffff00",
                description: "Cultivated areas, croplands, and managed fields"
            },
            grassland: {
                name: "Grassland/Shrubland",
                color: "#ccff66",
                description: "Areas dominated by grasses and shrubs"
            },
            forest: {
                name: "Forest/Woodland",
                color: "#009900",
                description: "Areas dominated by trees and dense vegetation"
            },
            wetland: {
                name: "Wetlands",
                color: "#33cccc",
                description: "Areas where water and land intermingle"
            }
        };

        // Classification algorithm for land cover based on NDVI and other rules
        function classifyLandCover(ndviValue, seasonalVariation, waterProximity = false) {
            // This is a simplified rule-based classifier
            // In a real application, you would use more sophisticated methods
            // and additional spectral indices
            
            if (ndviValue < -0.1) {
                return 'water'; // Deep water bodies typically have very negative NDVI
            }
            
            if (ndviValue < 0.1) {
                if (waterProximity) {
                    return 'wetland';
                }
                // Low NDVI could be urban or barren depending on other factors
                // Simplified logic for demo purposes
                return seasonalVariation < 0.1 ? 'urban' : 'barren';
            }
            
            if (ndviValue < 0.3) {
                // Sparse vegetation - could be barren, urban edges, or sparse shrubs
                return seasonalVariation < 0.15 ? 'urban' : 'barren';
            }
            
            if (ndviValue < 0.5) {
                // Moderate vegetation - likely grassland or cropland
                return seasonalVariation > 0.25 ? 'cropland' : 'grassland';
            }
            
            // High NDVI - likely forest or dense cropland
            return seasonalVariation < 0.2 ? 'forest' : 'cropland';
        }
        
        // Function to analyze land cover from NDVI data
        function analyzeLandCover(yearlyStats) {
            // We can only do this if we have the yearly stats data
            if (!yearlyStats || yearlyStats.length === 0) {
                alert('No NDVI data available. Please run the time series analysis first.');
                return null;
            }
            
            // Get the data to use - either the selected year or the most recent
            const latestYearData = yearlyStats[yearlyStats.length - 1];
            
            // If this is year-specific analysis, add year information to the title
            const selectedYear = document.getElementById('land-cover-year').value;
            window.currentLandCoverYear = selectedYear || latestYearData.year;
            
            // Calculate seasonal variation (simplistic approach - in a real application,
            // you would use multiple seasons of data)
            let seasonalVariation = 0.1; // Default value
            if (yearlyStats.length > 1) {
                const ndviValues = yearlyStats.map(stat => stat.basic_stats.mean_ndvi);
                const maxNdvi = Math.max(...ndviValues);
                const minNdvi = Math.min(...ndviValues);
                seasonalVariation = maxNdvi - minNdvi;
            }
            
            // For demonstration purposes, we'll simulate land cover classes based on NDVI distribution
            // In a real application, you would use actual multi-spectral satellite data
            const landCoverDistribution = {};
            const totalArea = parseFloat(latestYearData.total_area_hectares) || 0;
            
            // Validate total area - if it's not a valid number, use a default
            const validTotalArea = isNaN(totalArea) || totalArea <= 0 ? 1000 : totalArea;
            
            // Initialize counters for each land cover class
            Object.keys(landCoverClasses).forEach(key => {
                landCoverDistribution[key] = {
                    area_hectares: 0,
                    percentage: 0
                };
            });
            
            // Use NDVI distribution to estimate land cover
            // This is simplified for the demo - real classification would be much more complex
            const ndviRanges = [
                { min: -1.0, max: -0.1, classify: (v, s) => classifyLandCover(v, s, true) },
                { min: -0.1, max: 0.1, classify: (v, s) => classifyLandCover(v, s, false) },
                { min: 0.1, max: 0.3, classify: (v, s) => classifyLandCover(v, s, false) },
                { min: 0.3, max: 0.5, classify: (v, s) => classifyLandCover(v, s, false) },
                { min: 0.5, max: 1.0, classify: (v, s) => classifyLandCover(v, s, false) }
            ];
            
            // Distribute area based on NDVI distribution
            // This simulates what would happen with a proper classification
            ndviRanges.forEach(range => {
                // Estimate percentage of area in this NDVI range
                // For simplicity, we'll base this on vegetation distribution from NDVI
                let percentInRange = 0;
                
                // Check if area_stats exists and has all required properties
                if (latestYearData.area_stats) {
                    if (range.min < 0.1 && range.max >= -0.1 && latestYearData.area_stats.water_or_bare) {
                        percentInRange = (latestYearData.area_stats.water_or_bare.percentage || 0) / 100;
                    } else if (range.min < 0.3 && range.max >= 0.1 && latestYearData.area_stats.sparse_vegetation) {
                        percentInRange = (latestYearData.area_stats.sparse_vegetation.percentage || 0) / 100;
                    } else if (range.min < 0.6 && range.max >= 0.3 && latestYearData.area_stats.moderate_vegetation) {
                        percentInRange = (latestYearData.area_stats.moderate_vegetation.percentage || 0) / 100;
                    } else if (latestYearData.area_stats.dense_vegetation) {
                        percentInRange = (latestYearData.area_stats.dense_vegetation.percentage || 0) / 100;
                    }
                }
                
                // Validate percentInRange to prevent NaN values
                percentInRange = isNaN(percentInRange) ? 0 : Math.max(0, Math.min(1, percentInRange));
                
                // Adjust percentages for demonstration
                if (range.min < 0) {
                    // Water bodies usually occupy a portion of the lowest NDVI range
                    const landCoverType = 'water';
                    const areaHectares = validTotalArea * (percentInRange * 0.7); // Assume 70% of this range is water
                    landCoverDistribution[landCoverType].area_hectares += areaHectares;
                    
                    // The remainder could be wetlands
                    const wetlandHectares = validTotalArea * (percentInRange * 0.3);
                    landCoverDistribution['wetland'].area_hectares += wetlandHectares;
                } else if (range.min < 0.1) {
                    // Low NDVI areas are often urban or barren
                    const urbanHectares = validTotalArea * (percentInRange * 0.6); // 60% urban
                    landCoverDistribution['urban'].area_hectares += urbanHectares;
                    
                    const barrenHectares = validTotalArea * (percentInRange * 0.4); // 40% barren
                    landCoverDistribution['barren'].area_hectares += barrenHectares;
                } else if (range.min < 0.3) {
                    // Sparse vegetation areas
                    const grasslandHectares = validTotalArea * (percentInRange * 0.7); // 70% grassland
                    landCoverDistribution['grassland'].area_hectares += grasslandHectares;
                    
                    const barrenHectares = validTotalArea * (percentInRange * 0.3); // 30% barren
                    landCoverDistribution['barren'].area_hectares += barrenHectares;
                } else if (range.min < 0.5) {
                    // Moderate vegetation areas
                    const croplandHectares = validTotalArea * (percentInRange * 0.6); // 60% cropland
                    landCoverDistribution['cropland'].area_hectares += croplandHectares;
                    
                    const grasslandHectares = validTotalArea * (percentInRange * 0.4); // 40% grassland
                    landCoverDistribution['grassland'].area_hectares += grasslandHectares;
                } else {
                    // Dense vegetation areas
                    const forestHectares = validTotalArea * (percentInRange * 0.8); // 80% forest
                    landCoverDistribution['forest'].area_hectares += forestHectares;
                    
                    const croplandHectares = validTotalArea * (percentInRange * 0.2); // 20% cropland
                    landCoverDistribution['cropland'].area_hectares += croplandHectares;
                }
            });
            
            // Calculate percentages and ensure all values are valid numbers
            Object.keys(landCoverDistribution).forEach(key => {
                // Ensure area_hectares is a valid number
                if (isNaN(landCoverDistribution[key].area_hectares)) {
                    landCoverDistribution[key].area_hectares = 0;
                }
                
                // Calculate percentage (avoid division by zero)
                landCoverDistribution[key].percentage = validTotalArea > 0 ? 
                    (landCoverDistribution[key].area_hectares / validTotalArea) * 100 : 0;
                
                // Final validation to prevent NaN
                if (isNaN(landCoverDistribution[key].percentage)) {
                    landCoverDistribution[key].percentage = 0;
                }
            });
            
            return {
                landCoverDistribution,
                totalArea: validTotalArea
            };
        }
        
        // Function to display land cover analysis results
        function displayLandCoverResults(landCoverResults) {
            if (!landCoverResults) return;
            
            const { landCoverDistribution, totalArea } = landCoverResults;
            
            // Sort land cover types by percentage (descending)
            const sortedLandCover = Object.entries(landCoverDistribution)
                .map(([key, value]) => ({ 
                    key, 
                    ...value, 
                    name: landCoverClasses[key].name,
                    color: landCoverClasses[key].color,
                    description: landCoverClasses[key].description
                }))
                .sort((a, b) => b.percentage - a.percentage);
            
            // Create a new div for the land cover results
            const landCoverDiv = document.createElement('div');
            landCoverDiv.className = 'land-cover-results';
            landCoverDiv.style.marginTop = '20px';
            landCoverDiv.style.padding = '15px';
            landCoverDiv.style.backgroundColor = '#fff';
            landCoverDiv.style.border = '1px solid #ddd';
            landCoverDiv.style.borderRadius = '5px';
            
            // Add a title with year if available
            const titleDiv = document.createElement('div');
            titleDiv.className = 'stats-title';
            titleDiv.textContent = window.currentLandCoverYear ? 
                `Land Cover Classification (${window.currentLandCoverYear})` : 
                'Land Cover Classification';
            landCoverDiv.appendChild(titleDiv);
            
            // Add a description
            const descDiv = document.createElement('div');
            descDiv.style.fontSize = '13px';
            descDiv.style.marginBottom = '15px';
            descDiv.style.color = '#666';
            descDiv.textContent = 'Estimated land cover types based on NDVI patterns and vegetation distribution.';
            landCoverDiv.appendChild(descDiv);
            
            // Create a container for the land cover types
            const landCoverTypesDiv = document.createElement('div');
            landCoverDiv.appendChild(landCoverTypesDiv);
            
            // Add each land cover type with its percentage and visualization
            sortedLandCover.forEach(landCover => {
                if (landCover.percentage < 0.1) return; // Skip very small percentages
                
                const landCoverTypeDiv = document.createElement('div');
                landCoverTypeDiv.className = 'vegetation-type';
                landCoverTypeDiv.style.marginBottom = '15px';
                landCoverTypeDiv.style.padding = '10px';
                landCoverTypeDiv.style.borderRadius = '5px';
                landCoverTypeDiv.style.backgroundColor = '#f8f9fa';
                landCoverTypesDiv.appendChild(landCoverTypeDiv);
                
                // Create the header with name and area
                const headerDiv = document.createElement('div');
                headerDiv.className = 'vegetation-header';
                headerDiv.style.display = 'flex';
                headerDiv.style.justifyContent = 'space-between';
                headerDiv.style.marginBottom = '5px';
                landCoverTypeDiv.appendChild(headerDiv);
                
                // Add the name with a color indicator
                const nameDiv = document.createElement('div');
                nameDiv.className = 'vegetation-name';
                nameDiv.style.fontWeight = 'bold';
                nameDiv.style.display = 'flex';
                nameDiv.style.alignItems = 'center';
                headerDiv.appendChild(nameDiv);
                
                const colorIndicator = document.createElement('span');
                colorIndicator.style.display = 'inline-block';
                colorIndicator.style.width = '16px';
                colorIndicator.style.height = '16px';
                colorIndicator.style.backgroundColor = landCover.color;
                colorIndicator.style.marginRight = '8px';
                colorIndicator.style.borderRadius = '3px';
                nameDiv.appendChild(colorIndicator);
                
                const nameText = document.createElement('span');
                nameText.textContent = landCover.name;
                nameDiv.appendChild(nameText);
                
                // Add the area information
                const areaDiv = document.createElement('div');
                areaDiv.className = 'vegetation-area';
                areaDiv.style.color = '#666';
                areaDiv.textContent = `${landCover.area_hectares.toFixed(2)} ha (${landCover.percentage.toFixed(1)}%)`;
                headerDiv.appendChild(areaDiv);
                
                // Add a description
                const descriptionDiv = document.createElement('div');
                descriptionDiv.style.fontSize = '13px';
                descriptionDiv.style.marginBottom = '8px';
                descriptionDiv.style.color = '#666';
                descriptionDiv.textContent = landCover.description;
                landCoverTypeDiv.appendChild(descriptionDiv);
                
                // Add a progress bar
                const progressBarDiv = document.createElement('div');
                progressBarDiv.className = 'progress-bar';
                progressBarDiv.style.height = '10px';
                progressBarDiv.style.backgroundColor = '#e9ecef';
                progressBarDiv.style.borderRadius = '5px';
                progressBarDiv.style.overflow = 'hidden';
                landCoverTypeDiv.appendChild(progressBarDiv);
                
                const progressFillDiv = document.createElement('div');
                progressFillDiv.className = 'progress-fill';
                progressFillDiv.style.height = '100%';
                progressFillDiv.style.width = `${landCover.percentage}%`;
                progressFillDiv.style.backgroundColor = landCover.color;
                progressFillDiv.style.transition = 'width 0.3s ease';
                progressBarDiv.appendChild(progressFillDiv);
            });
            
            // Create a canvas for the pie chart
            const chartContainer = document.createElement('div');
            chartContainer.style.marginTop = '20px';
            chartContainer.style.height = '300px';
            landCoverDiv.appendChild(chartContainer);
            
            const canvas = document.createElement('canvas');
            canvas.id = 'landCoverChart';
            chartContainer.appendChild(canvas);
            
            // Add the land cover div to the results
            const resultsDiv = document.getElementById('results');
            
            // Check if there's already a land cover results div and remove it
            const existingLandCoverDiv = document.querySelector('.land-cover-results');
            if (existingLandCoverDiv) {
                resultsDiv.removeChild(existingLandCoverDiv);
            }
            
            resultsDiv.appendChild(landCoverDiv);
            
            // Create the pie chart
            const ctx = document.getElementById('landCoverChart').getContext('2d');
            new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: sortedLandCover.map(lc => lc.name),
                    datasets: [{
                        data: sortedLandCover.map(lc => lc.percentage),
                        backgroundColor: sortedLandCover.map(lc => lc.color),
                        borderColor: '#fff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 15,
                                padding: 15
                            }
                        },
                        title: {
                            display: true,
                            text: 'Land Cover Distribution'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const label = context.label || '';
                                    return `${label}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Handle land cover UI controls
        document.getElementById('enable-land-cover').addEventListener('change', function() {
            const runLandCoverBtn = document.getElementById('run-land-cover-btn');
            runLandCoverBtn.disabled = !this.checked;
            
            // Show/hide year picker
            document.getElementById('land-cover-year-container').style.display = this.checked ? 'block' : 'none';
            
            // Enable/disable the radio buttons based on checkbox state
            const radioInputs = document.querySelectorAll('input[name="classification-type"]');
            radioInputs.forEach(radio => {
                radio.disabled = !this.checked;
            });
        });

        // Initialize radio buttons to be disabled (since checkbox starts unchecked)
        const radioInputs = document.querySelectorAll('input[name="classification-type"]');
        radioInputs.forEach(radio => {
            radio.disabled = true;
            
            // Add event listener to toggle legends based on classification type
            radio.addEventListener('change', function() {
                const ndviLegend = document.querySelector('.legend:not(#dynamic-world-legend)');
                const dynamicWorldLegend = document.getElementById('dynamic-world-legend');
                
                if (this.value === 'ndvi') {
                    ndviLegend.style.display = 'block';
                    dynamicWorldLegend.style.display = 'none';
                } else if (this.value === 'dynamicworld') {
                    ndviLegend.style.display = 'none';
                    dynamicWorldLegend.style.display = 'block';
                }
            });
        });

        // Function to get IGBP land cover classification
function getIGBPLandCover(coordinates, startDate, endDate) {
    return fetch('/get_igbp_land_cover', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            coordinates: coordinates,
            start_date: startDate,
            end_date: endDate
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            return data.igbp_data;
        } else {
            throw new Error(data.error || 'Failed to get IGBP land cover data');
        }
    });
}

// Function to get ESA WorldCover classification
function getESAWorldCover(coordinates) {
    return fetch('/get_esa_worldcover', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            coordinates: coordinates
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            return data.worldcover_data;
        } else {
            throw new Error(data.error || 'Failed to get ESA WorldCover data');
        }
    });
}

// Function to get Dynamic World classification
function getDynamicWorld(coordinates) {
    return fetch('/get_dynamic_world', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            coordinates: coordinates
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            return data.dynamicworld_data;
        } else {
            throw new Error(data.error || 'Failed to get Dynamic World data');
        }
    });
}

        // Function to display IGBP land cover results
        function displayIGBPLandCoverResults(igbpData) {
            // Get the results div
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // Clear any existing results
            
            // Create a title for the results
            const titleDiv = document.createElement('div');
            titleDiv.className = 'stats-title';
            titleDiv.textContent = 'IGBP Land Cover Classification';
            titleDiv.style.fontSize = '18px';
            titleDiv.style.fontWeight = 'bold';
            titleDiv.style.marginBottom = '10px';
            resultsDiv.appendChild(titleDiv);
            
            // Create the subtitle with year info
            const subtitleDiv = document.createElement('div');
            subtitleDiv.className = 'stats-subtitle';
            subtitleDiv.textContent = `Analysis for year ${igbpData.year}`;
            subtitleDiv.style.fontSize = '14px';
            subtitleDiv.style.marginBottom = '15px';
            subtitleDiv.style.color = '#666';
            resultsDiv.appendChild(subtitleDiv);
            
            // Add the description
            const descDiv = document.createElement('div');
            descDiv.style.fontSize = '13px';
            descDiv.style.marginBottom = '20px';
            descDiv.style.color = '#666';
            descDiv.textContent = 'Classification based on the International Geosphere-Biosphere Programme (IGBP) land cover categories.';
            resultsDiv.appendChild(descDiv);
            
            // Create a container for the IGBP land cover classes
            const landCoverTypesDiv = document.createElement('div');
            resultsDiv.appendChild(landCoverTypesDiv);
            
            // Sort land cover classes by percentage (descending)
            const sortedLandCover = Object.entries(igbpData.area_stats).map(([name, stats]) => {
                return {
                    name: name,
                    color: stats.color,
                    area_hectares: stats.area_hectares,
                    percentage: stats.percentage,
                    class_value: stats.class_value
                };
            }).sort((a, b) => b.percentage - a.percentage);
            
            // Add each land cover type with its percentage and visualization
            sortedLandCover.forEach(landCover => {
                if (landCover.percentage < 0.1) return; // Skip very small percentages
                
                const landCoverTypeDiv = document.createElement('div');
                landCoverTypeDiv.className = 'land-cover-type';
                landCoverTypeDiv.style.marginBottom = '15px';
                landCoverTypeDiv.style.padding = '10px';
                landCoverTypeDiv.style.borderRadius = '5px';
                landCoverTypeDiv.style.backgroundColor = '#f8f9fa';
                landCoverTypesDiv.appendChild(landCoverTypeDiv);
                
                // Create the header with name and area
                const headerDiv = document.createElement('div');
                headerDiv.style.display = 'flex';
                headerDiv.style.justifyContent = 'space-between';
                headerDiv.style.marginBottom = '5px';
                landCoverTypeDiv.appendChild(headerDiv);
                
                // Add the name with a color indicator
                const nameDiv = document.createElement('div');
                nameDiv.style.fontWeight = 'bold';
                nameDiv.style.display = 'flex';
                nameDiv.style.alignItems = 'center';
                headerDiv.appendChild(nameDiv);
                
                const colorIndicator = document.createElement('span');
                colorIndicator.style.display = 'inline-block';
                colorIndicator.style.width = '16px';
                colorIndicator.style.height = '16px';
                colorIndicator.style.backgroundColor = landCover.color;
                colorIndicator.style.marginRight = '8px';
                colorIndicator.style.borderRadius = '3px';
                nameDiv.appendChild(colorIndicator);
                
                const nameText = document.createElement('span');
                nameText.textContent = landCover.name;
                nameDiv.appendChild(nameText);
                
                // Add the area information
                const areaDiv = document.createElement('div');
                areaDiv.style.color = '#666';
                areaDiv.textContent = `${landCover.area_hectares.toFixed(2)} ha (${landCover.percentage.toFixed(1)}%)`;
                headerDiv.appendChild(areaDiv);
                
                // Create a progress bar to visualize the percentage
                const progressContainer = document.createElement('div');
                progressContainer.style.width = '100%';
                progressContainer.style.height = '6px';
                progressContainer.style.backgroundColor = '#e0e0e0';
                progressContainer.style.borderRadius = '3px';
                progressContainer.style.overflow = 'hidden';
                progressContainer.style.marginTop = '5px';
                landCoverTypeDiv.appendChild(progressContainer);
                
                const progressBar = document.createElement('div');
                progressBar.style.width = `${landCover.percentage}%`;
                progressBar.style.height = '100%';
                progressBar.style.backgroundColor = landCover.color;
                progressContainer.appendChild(progressBar);
            });
            
            // If there are no land cover classes with data, show a message
            if (sortedLandCover.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.textContent = 'No land cover data available for this area.';
                noDataDiv.style.fontStyle = 'italic';
                noDataDiv.style.color = '#666';
                resultsDiv.appendChild(noDataDiv);
                return;
            }
            
            // Create a pie chart of the land cover distribution
            const chartContainer = document.createElement('div');
            chartContainer.style.marginTop = '30px';
            chartContainer.style.height = '300px';
            resultsDiv.appendChild(chartContainer);
            
            const chartCanvas = document.createElement('canvas');
            chartCanvas.id = 'igbpLandCoverChart';
            chartContainer.appendChild(chartCanvas);
            
            // Prepare data for the chart
            const chartData = {
                labels: sortedLandCover.map(lc => lc.name),
                datasets: [{
                    data: sortedLandCover.map(lc => lc.percentage),
                    backgroundColor: sortedLandCover.map(lc => lc.color),
                }]
            };
            
            // Create the chart
            new Chart(document.getElementById('igbpLandCoverChart').getContext('2d'), {
                type: 'pie',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 15,
                                padding: 15
                            }
                        },
                        title: {
                            display: true,
                            text: 'IGBP Land Cover Distribution'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const label = context.label || '';
                                    return `${label}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Add the IGBP layer to the map
            if (window.igbpLayer) {
                map.removeLayer(window.igbpLayer);
            }
            
            window.igbpLayer = L.tileLayer(igbpData.tile_url);
            window.igbpLayer.addTo(map);
            
            // Add IGBP layer to map controls
            if (!document.getElementById('igbp-toggle')) {
                // Add a control for the IGBP layer in the map controls panel
                const controlsContainer = document.querySelector('.map-controls');
                const ndviControlSection = document.querySelector('.control-section');
                const igbpControlSection = document.createElement('div');
                igbpControlSection.className = 'control-section';
                igbpControlSection.innerHTML = `
                    <div class="control-section-title">IGBP Land Cover</div>
                    <div class="control-item">
                        <input type="checkbox" id="igbp-toggle" checked>
                        <label for="igbp-toggle">IGBP Land Cover</label>
                    </div>
                    <input type="range" id="igbp-opacity" class="opacity-slider" min="0" max="100" value="80">
                    <div class="opacity-value" id="igbp-opacity-value">80%</div>
                `;
                
                if (ndviControlSection && ndviControlSection.parentNode) {
                    ndviControlSection.parentNode.insertBefore(igbpControlSection, ndviControlSection.nextSibling);
                } else if (controlsContainer) {
                    controlsContainer.appendChild(igbpControlSection);
                }
                
                // Add event listener for the IGBP toggle
                document.getElementById('igbp-toggle').addEventListener('change', function() {
                    if (this.checked && window.igbpLayer) {
                        map.addLayer(window.igbpLayer);
                    } else if (window.igbpLayer) {
                        map.removeLayer(window.igbpLayer);
                    }
                });
                
                // Add event listener for opacity control
                document.getElementById('igbp-opacity').addEventListener('input', function() {
                    const opacity = parseFloat(this.value) / 100;
                    if (window.igbpLayer) {
                        window.igbpLayer.setOpacity(opacity);
                    }
                    document.getElementById('igbp-opacity-value').textContent = `${this.value}%`;
                });
            }
        }

        // Function to display ESA WorldCover results
function displayESAWorldCoverResults(worldcoverData) {
    // Get the results div
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = ''; // Clear any existing results
    
    // Create a title for the results
    const titleDiv = document.createElement('div');
    titleDiv.className = 'stats-title';
    titleDiv.textContent = 'ESA WorldCover 10m Classification';
    titleDiv.style.fontSize = '18px';
    titleDiv.style.fontWeight = 'bold';
    titleDiv.style.marginBottom = '10px';
    resultsDiv.appendChild(titleDiv);
    
    // Create the subtitle with year info
    const subtitleDiv = document.createElement('div');
    subtitleDiv.className = 'stats-subtitle';
    subtitleDiv.textContent = `Analysis for year ${worldcoverData.year}`;
    subtitleDiv.style.fontSize = '14px';
    subtitleDiv.style.marginBottom = '15px';
    subtitleDiv.style.color = '#666';
    resultsDiv.appendChild(subtitleDiv);
    
    // Add the description
    const descDiv = document.createElement('div');
    descDiv.style.fontSize = '13px';
    descDiv.style.marginBottom = '20px';
    descDiv.style.color = '#666';
    descDiv.textContent = 'Classification based on the ESA WorldCover 10m v100 dataset, which provides a global land cover map at 10m resolution based on Sentinel-1 and Sentinel-2 data.';
    resultsDiv.appendChild(descDiv);
    
    // Create a container for the ESA WorldCover classes
    const landCoverTypesDiv = document.createElement('div');
    resultsDiv.appendChild(landCoverTypesDiv);
    
    // Sort land cover classes by percentage (descending)
    const sortedLandCover = Object.entries(worldcoverData.area_stats).map(([name, stats]) => {
        return {
            name: name,
            color: stats.color,
            area_hectares: stats.area_hectares,
            percentage: stats.percentage,
            class_value: stats.class_value
        };
    }).sort((a, b) => b.percentage - a.percentage);
    
    // Add each land cover type with its percentage and visualization
    sortedLandCover.forEach(landCover => {
        if (landCover.percentage < 0.1) return; // Skip very small percentages
        
        const landCoverTypeDiv = document.createElement('div');
        landCoverTypeDiv.className = 'land-cover-type';
        landCoverTypeDiv.style.marginBottom = '15px';
        landCoverTypeDiv.style.padding = '10px';
        landCoverTypeDiv.style.borderRadius = '5px';
        landCoverTypeDiv.style.backgroundColor = '#f8f9fa';
        landCoverTypesDiv.appendChild(landCoverTypeDiv);
        
        // Create the header with name and area
        const headerDiv = document.createElement('div');
        headerDiv.style.display = 'flex';
        headerDiv.style.justifyContent = 'space-between';
        headerDiv.style.marginBottom = '5px';
        landCoverTypeDiv.appendChild(headerDiv);
        
        // Add the name with a color indicator
        const nameDiv = document.createElement('div');
        nameDiv.style.fontWeight = 'bold';
        nameDiv.style.display = 'flex';
        nameDiv.style.alignItems = 'center';
        headerDiv.appendChild(nameDiv);
        
        const colorIndicator = document.createElement('span');
        colorIndicator.style.display = 'inline-block';
        colorIndicator.style.width = '16px';
        colorIndicator.style.height = '16px';
        colorIndicator.style.backgroundColor = landCover.color;
        colorIndicator.style.marginRight = '8px';
        colorIndicator.style.borderRadius = '3px';
        nameDiv.appendChild(colorIndicator);
        
        const nameText = document.createElement('span');
        nameText.textContent = landCover.name;
        nameDiv.appendChild(nameText);
        
        // Add the area information
        const areaDiv = document.createElement('div');
        areaDiv.style.color = '#666';
        areaDiv.textContent = `${landCover.area_hectares.toFixed(2)} ha (${landCover.percentage.toFixed(1)}%)`;
        headerDiv.appendChild(areaDiv);
        
        // Create a progress bar to visualize the percentage
        const progressContainer = document.createElement('div');
        progressContainer.style.width = '100%';
        progressContainer.style.height = '6px';
        progressContainer.style.backgroundColor = '#e0e0e0';
        progressContainer.style.borderRadius = '3px';
        progressContainer.style.overflow = 'hidden';
        progressContainer.style.marginTop = '5px';
        landCoverTypeDiv.appendChild(progressContainer);
        
        const progressBar = document.createElement('div');
        progressBar.style.width = `${landCover.percentage}%`;
        progressBar.style.height = '100%';
        progressBar.style.backgroundColor = landCover.color;
        progressContainer.appendChild(progressBar);
    });
    
    // If there are no land cover classes with data, show a message
    if (sortedLandCover.length === 0) {
        const noDataDiv = document.createElement('div');
        noDataDiv.textContent = 'No land cover data available for this area.';
        noDataDiv.style.fontStyle = 'italic';
        noDataDiv.style.color = '#666';
        resultsDiv.appendChild(noDataDiv);
        return;
    }
    
    // Create a pie chart of the land cover distribution
    const chartContainer = document.createElement('div');
    chartContainer.style.marginTop = '30px';
    chartContainer.style.height = '300px';
    resultsDiv.appendChild(chartContainer);
    
    const chartCanvas = document.createElement('canvas');
    chartCanvas.id = 'esaWorldcoverChart';
    chartContainer.appendChild(chartCanvas);
    
    // Prepare data for the chart
    const chartData = {
        labels: sortedLandCover.map(lc => lc.name),
        datasets: [{
            data: sortedLandCover.map(lc => lc.percentage),
            backgroundColor: sortedLandCover.map(lc => lc.color),
        }]
    };
    
    // Create the chart
    new Chart(document.getElementById('esaWorldcoverChart').getContext('2d'), {
        type: 'pie',
        data: chartData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        boxWidth: 15,
                        padding: 15
                    }
                },
                title: {
                    display: true,
                    text: 'ESA WorldCover Distribution'
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            const label = context.label || '';
                            return `${label}: ${value.toFixed(1)}%`;
                        }
                    }
                }
            }
        }
    });
    
    // Add the ESA WorldCover layer to the map
    if (window.worldcoverLayer) {
        map.removeLayer(window.worldcoverLayer);
    }
    
    window.worldcoverLayer = L.tileLayer(worldcoverData.tile_url);
    window.worldcoverLayer.addTo(map);
    
    // Add ESA WorldCover layer to map controls
    if (!document.getElementById('worldcover-toggle')) {
        // Add a control for the ESA WorldCover layer in the map controls panel
        const controlsContainer = document.querySelector('.map-controls');
        const ndviControlSection = document.querySelector('.control-section');
        const worldcoverControlSection = document.createElement('div');
        worldcoverControlSection.className = 'control-section';
        worldcoverControlSection.innerHTML = `
            <div class="control-section-title">ESA WorldCover Layer</div>
            <div class="control-item">
                <input type="checkbox" id="worldcover-toggle" checked>
                <label for="worldcover-toggle">ESA WorldCover</label>
            </div>
            <input type="range" id="worldcover-opacity" class="opacity-slider" min="0" max="100" value="80">
            <div class="opacity-value" id="worldcover-opacity-value">80%</div>
        `;
        
        if (ndviControlSection && ndviControlSection.parentNode) {
            ndviControlSection.parentNode.insertBefore(worldcoverControlSection, ndviControlSection.nextSibling);
        } else if (controlsContainer) {
            controlsContainer.appendChild(worldcoverControlSection);
        }
        
        // Add event listener for the ESA WorldCover toggle
        document.getElementById('worldcover-toggle').addEventListener('change', function() {
            if (this.checked && window.worldcoverLayer) {
                map.addLayer(window.worldcoverLayer);
            } else if (window.worldcoverLayer) {
                map.removeLayer(window.worldcoverLayer);
            }
        });
        
        // Add event listener for opacity control
        document.getElementById('worldcover-opacity').addEventListener('input', function() {
            const opacity = parseFloat(this.value) / 100;
            if (window.worldcoverLayer) {
                window.worldcoverLayer.setOpacity(opacity);
            }
            document.getElementById('worldcover-opacity-value').textContent = `${this.value}%`;
        });
    }
}

        // Land cover analysis button handler
        document.getElementById('run-land-cover-btn').addEventListener('click', function() {
            // Get the model type from the global selection
            const modelType = document.querySelector('input[name="model-type"]:checked').value;
            
            // Check if we need time series data for NDVI classification
            if (modelType === 'ndvi' && (!window.yearlyStatsData || window.yearlyStatsData.length === 0)) {
                alert('Need time series data to perform NDVI-based land cover analysis. Please run the time series analysis first.');
                return;
            }
            
            // Check if we have coordinates
            if (!currentCoordinates) {
                alert('Please draw an area on the map first.');
                return;
            }
            
            // Get the selected year
            const selectedYear = document.getElementById('land-cover-year').value;
            
            // Show loading screen
            showLoading('Analyzing Land Cover', selectedYear ? 
                `Processing land cover data for ${selectedYear}...` : 
                'Processing latest land cover data...');
            
            if (modelType === 'ndvi') {
                // Run the NDVI-based land cover analysis
                const selectedYear = document.getElementById('land-cover-year').value;
                let yearlyData = window.yearlyStatsData;
                
                // Filter data by selected year if specified
                if (selectedYear && window.yearlyStatsData) {
                    const selectedYearData = window.yearlyStatsData.find(data => data.year == selectedYear);
                    if (selectedYearData) {
                        yearlyData = [selectedYearData]; // Use only the selected year's data
                        console.log(`Using NDVI data for selected year: ${selectedYear}`);
                    } else {
                        console.warn(`No NDVI data found for year ${selectedYear}`);
                    }
                }
                
                const landCoverResults = analyzeLandCover(yearlyData);
            
            // Display the results
            displayLandCoverResults(landCoverResults);
                
            // Hide loading screen
            hideLoading();
            } else if (modelType === 'dynamicworld') {
                // Show loading indicator
                document.getElementById('results').innerHTML = '<div class="loading">Loading Dynamic World data...</div>';
                
                if (selectedYear) {
                    // Get Dynamic World data for the specific year
                    fetch('/get_dynamic_world_for_year', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            coordinates: currentCoordinates,
                            year: parseInt(selectedYear)
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Display the results
                            displayDynamicWorldResults(data.dynamicworld_data);
                            // Hide loading screen
                            hideLoading();
                        } else {
                            document.getElementById('results').innerHTML = `<p class="error">Error: ${data.error}</p>`;
                            // Hide loading screen
                            hideLoading();
                        }
                    })
                    .catch(error => {
                        document.getElementById('results').innerHTML = `<p class="error">Error: ${error.message}</p>`;
                        // Hide loading screen on error
                        hideLoading();
                    });
                } else {
                    // Get latest Dynamic World data
                    getDynamicWorld(currentCoordinates)
                        .then(dynamicWorldData => {
                            // Display the results
                            displayDynamicWorldResults(dynamicWorldData);
                            // Hide loading screen
                            hideLoading();
                        })
                        .catch(error => {
                            document.getElementById('results').innerHTML = `<p class="error">Error: ${error.message}</p>`;
                            // Hide loading screen on error
                            hideLoading();
                        });
                }
            }
        });

        // Function to display Dynamic World results
        function displayDynamicWorldResults(dynamicWorldData) {
            // Get the results div
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = ''; // Clear any existing results
            
            // Create a title for the results
            const titleDiv = document.createElement('div');
            titleDiv.className = 'stats-title';
            titleDiv.textContent = 'Dynamic World V1 Land Cover Classification';
            titleDiv.style.fontSize = '18px';
            titleDiv.style.fontWeight = 'bold';
            titleDiv.style.marginBottom = '10px';
            resultsDiv.appendChild(titleDiv);
            
            // Create the subtitle with date info
            const subtitleDiv = document.createElement('div');
            subtitleDiv.className = 'stats-subtitle';
            subtitleDiv.textContent = `Analysis for date ${dynamicWorldData.date}`;
            subtitleDiv.style.fontSize = '14px';
            subtitleDiv.style.marginBottom = '15px';
            subtitleDiv.style.color = '#666';
            resultsDiv.appendChild(subtitleDiv);
            
            // Add the description
            const descDiv = document.createElement('div');
            descDiv.style.fontSize = '13px';
            descDiv.style.marginBottom = '20px';
            descDiv.style.color = '#666';
            descDiv.textContent = 'Classification based on Dynamic World V1, a near-real-time 10m land use/land cover dataset.';
            resultsDiv.appendChild(descDiv);
            
            // Create a container for the Dynamic World land cover classes
            const landCoverTypesDiv = document.createElement('div');
            resultsDiv.appendChild(landCoverTypesDiv);
            
            // Sort land cover classes by percentage (descending)
            const sortedLandCover = Object.entries(dynamicWorldData.area_stats).map(([name, stats]) => {
                return {
                    name: name,
                    color: stats.color,
                    area_hectares: stats.area_hectares,
                    percentage: stats.percentage,
                    class_value: stats.class_value
                };
            }).sort((a, b) => b.percentage - a.percentage);
            
            // Add each land cover type with its percentage and visualization
            sortedLandCover.forEach(landCover => {
                if (landCover.percentage < 0.1) return; // Skip very small percentages
                
                const landCoverTypeDiv = document.createElement('div');
                landCoverTypeDiv.className = 'land-cover-type';
                landCoverTypeDiv.style.marginBottom = '15px';
                landCoverTypeDiv.style.padding = '10px';
                landCoverTypeDiv.style.borderRadius = '5px';
                landCoverTypeDiv.style.backgroundColor = '#f8f9fa';
                landCoverTypesDiv.appendChild(landCoverTypeDiv);
                
                // Create the header with name and area
                const headerDiv = document.createElement('div');
                headerDiv.style.display = 'flex';
                headerDiv.style.justifyContent = 'space-between';
                headerDiv.style.marginBottom = '5px';
                landCoverTypeDiv.appendChild(headerDiv);
                
                // Add the name with a color indicator
                const nameDiv = document.createElement('div');
                nameDiv.style.fontWeight = 'bold';
                nameDiv.style.display = 'flex';
                nameDiv.style.alignItems = 'center';
                headerDiv.appendChild(nameDiv);
                
                const colorIndicator = document.createElement('span');
                colorIndicator.style.display = 'inline-block';
                colorIndicator.style.width = '16px';
                colorIndicator.style.height = '16px';
                colorIndicator.style.backgroundColor = landCover.color;
                colorIndicator.style.marginRight = '8px';
                colorIndicator.style.borderRadius = '3px';
                nameDiv.appendChild(colorIndicator);
                
                const nameText = document.createElement('span');
                nameText.textContent = landCover.name;
                nameDiv.appendChild(nameText);
                
                // Add the area information
                const areaDiv = document.createElement('div');
                areaDiv.style.color = '#666';
                areaDiv.textContent = `${landCover.area_hectares.toFixed(2)} ha (${landCover.percentage.toFixed(1)}%)`;
                headerDiv.appendChild(areaDiv);
                
                // Create a progress bar to visualize the percentage
                const progressContainer = document.createElement('div');
                progressContainer.style.width = '100%';
                progressContainer.style.height = '6px';
                progressContainer.style.backgroundColor = '#e0e0e0';
                progressContainer.style.borderRadius = '3px';
                progressContainer.style.overflow = 'hidden';
                progressContainer.style.marginTop = '5px';
                landCoverTypeDiv.appendChild(progressContainer);
                
                const progressBar = document.createElement('div');
                progressBar.style.width = `${landCover.percentage}%`;
                progressBar.style.height = '100%';
                progressBar.style.backgroundColor = landCover.color;
                progressContainer.appendChild(progressBar);
            });
            
            // If there are no land cover classes with data, show a message
            if (sortedLandCover.length === 0) {
                const noDataDiv = document.createElement('div');
                noDataDiv.textContent = 'No land cover data available for this area.';
                noDataDiv.style.fontStyle = 'italic';
                noDataDiv.style.color = '#666';
                resultsDiv.appendChild(noDataDiv);
                return;
            }
            
            // Create a pie chart of the land cover distribution
            const chartContainer = document.createElement('div');
            chartContainer.style.marginTop = '30px';
            chartContainer.style.height = '300px';
            resultsDiv.appendChild(chartContainer);
            
            const chartCanvas = document.createElement('canvas');
            chartCanvas.id = 'dynamicWorldChart';
            chartContainer.appendChild(chartCanvas);
            
            // Prepare data for the chart
            const chartData = {
                labels: sortedLandCover.map(lc => lc.name),
                datasets: [{
                    data: sortedLandCover.map(lc => lc.percentage),
                    backgroundColor: sortedLandCover.map(lc => lc.color),
                }]
            };
            
            // Create the chart
            new Chart(document.getElementById('dynamicWorldChart').getContext('2d'), {
                type: 'pie',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 15,
                                padding: 15
                            }
                        },
                        title: {
                            display: true,
                            text: 'Dynamic World Land Cover Distribution'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const label = context.label || '';
                                    return `${label}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Add the Dynamic World layer to the map
            if (window.dynamicWorldLayer) {
                map.removeLayer(window.dynamicWorldLayer);
            }
            
            window.dynamicWorldLayer = L.tileLayer(dynamicWorldData.tile_url);
            window.dynamicWorldLayer.addTo(map);
            
            // Add Dynamic World layer to map controls
            if (!document.getElementById('dynamicworld-toggle')) {
                // Add a control for the Dynamic World layer in the map controls panel
                const controlsContainer = document.querySelector('.map-controls');
                const ndviControlSection = document.querySelector('.control-section');
                const dynamicWorldControlSection = document.createElement('div');
                dynamicWorldControlSection.className = 'control-section';
                dynamicWorldControlSection.innerHTML = `
                    <div class="control-section-title">Dynamic World Layer</div>
                    <div class="control-item">
                        <input type="checkbox" id="dynamicworld-toggle" checked>
                        <label for="dynamicworld-toggle">Dynamic World V1</label>
                    </div>
                    <input type="range" id="dynamicworld-opacity" class="opacity-slider" min="0" max="100" value="80">
                    <div class="opacity-value" id="dynamicworld-opacity-value">80%</div>
                `;
                
                if (ndviControlSection && ndviControlSection.parentNode) {
                    ndviControlSection.parentNode.insertBefore(dynamicWorldControlSection, ndviControlSection.nextSibling);
                } else if (controlsContainer) {
                    controlsContainer.appendChild(dynamicWorldControlSection);
                }
                
                // Add event listener for the Dynamic World toggle
                document.getElementById('dynamicworld-toggle').addEventListener('change', function() {
                    if (this.checked && window.dynamicWorldLayer) {
                        map.addLayer(window.dynamicWorldLayer);
                    } else if (window.dynamicWorldLayer) {
                        map.removeLayer(window.dynamicWorldLayer);
                    }
                });
                
                // Add event listener for opacity control
                document.getElementById('dynamicworld-opacity').addEventListener('input', function() {
                    const opacity = parseFloat(this.value) / 100;
                    if (window.dynamicWorldLayer) {
                        window.dynamicWorldLayer.setOpacity(opacity);
                    }
                    document.getElementById('dynamicworld-opacity-value').textContent = `${this.value}%`;
                });
            }
            
            // Show the Dynamic World legend
            document.getElementById('dynamic-world-legend').style.display = 'block';
        }

        // Function to get Dynamic World time series data
        function getDynamicWorldTimeSeries(coordinates, startYear, endYear) {
            return fetch('/get_dynamic_world_timeseries', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: coordinates,
                    start_year: startYear,
                    end_year: endYear
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    return {
                        timeseriesData: data.timeseries_data,
                        mapTiles: data.map_tiles
                    };
                } else {
                    throw new Error(data.error || 'Failed to get Dynamic World time series data');
                }
            });
        }

        // Function to display Dynamic World time series results
                 function displayDynamicWorldTimeSeries(timeseriesData, mapTiles) {
            console.log('Initializing Dynamic World time series visualization');
            
            // Reset all chart canvases first to prevent any chart conflicts
            resetChartCanvases();
            
            // Show the time series container - make sure it's visible
            const timeSeriesContainer = document.getElementById('time-series-results');
            timeSeriesContainer.style.display = 'block';
            console.log('Made time series container visible');
            
            try {
                // Extract years
                const years = timeseriesData.map(data => data.year);
                console.log('Processing Dynamic World data for years:', years.join(', '));
                
                // Get the context for the charts
                const ndviCanvas = document.getElementById('ndviChart');
                const vegetationCanvas = document.getElementById('vegetationChart');
                
                if (!ndviCanvas || !vegetationCanvas) {
                    console.error('Canvas elements not found:', 
                                 !ndviCanvas ? 'ndviChart missing' : '', 
                                 !vegetationCanvas ? 'vegetationChart missing' : '');
                    return;
                }
                
                const landCoverCtx = ndviCanvas.getContext('2d');
                const distributionCtx = vegetationCanvas.getContext('2d');
                
                // Organize data for charts
                const landCoverClasses = [];
                const classColors = {};
            const classData = {};
            
            // Initialize with all unique land cover classes across all years
            timeseriesData.forEach(yearData => {
                Object.entries(yearData.area_stats).forEach(([className, stats]) => {
                    if (!landCoverClasses.includes(className)) {
                        landCoverClasses.push(className);
                        classColors[className] = stats.color;
                        classData[className] = Array(timeseriesData.length).fill(0);
                    }
                });
            });
            
            // Fill in data for each year
            timeseriesData.forEach((yearData, yearIndex) => {
                landCoverClasses.forEach(className => {
                    if (yearData.area_stats[className]) {
                        classData[className][yearIndex] = yearData.area_stats[className].percentage;
                    }
                });
            });
            
            // Sort land cover classes by average percentage (descending)
            landCoverClasses.sort((a, b) => {
                const avgA = classData[a].reduce((sum, val) => sum + val, 0) / timeseriesData.length;
                const avgB = classData[b].reduce((sum, val) => sum + val, 0) / timeseriesData.length;
                return avgB - avgA;
            });
            
            // Create datasets for the chart
            const datasets = landCoverClasses.map(className => ({
                label: className,
                data: classData[className],
                backgroundColor: classColors[className],
                borderColor: classColors[className],
                fill: false
            }));
            
            // Create the land cover chart (line chart)
            window.ndviChart = new Chart(landCoverCtx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Dynamic World Land Cover Classes Over Time'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const label = context.dataset.label || '';
                                    return `${label}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Percentage of Area'
                            },
                            stacked: false
                        }
                    }
                }
            });
            
            // Create stacked bar datasets for land cover distribution
            const stackedDatasets = landCoverClasses.map(className => ({
                label: className,
                data: classData[className],
                backgroundColor: classColors[className],
                borderWidth: 1,
                borderColor: '#fff'
            }));
            
            // Create the stacked bar chart for land cover distribution
            window.vegetationChart = new Chart(distributionCtx, {
                type: 'bar',
                data: {
                    labels: years,
                    datasets: stackedDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Land Cover Distribution by Year'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const label = context.dataset.label || '';
                                    return `${label}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Year'
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Percentage'
                            }
                        }
                    }
                }
            });
            
            // Initialize animation with the map tiles
            initializeAnimation(mapTiles);
            
            // Update the results section
            const resultsDiv = document.getElementById('results');
            
            let html = '<div class="stats-section">';
            html += `<div class="stats-title">Dynamic World Time Series Analysis (${years[0]} - ${years[years.length - 1]})</div>`;
            
            // Show summary of changes
            const firstYear = timeseriesData[0];
            const lastYear = timeseriesData[timeseriesData.length - 1];
            
            html += '<div class="stats-title" style="margin-top: 20px;">Land Cover Change Summary</div>';
            html += '<div style="margin-bottom: 20px; font-size: 13px; color: #666;">Showing changes between the first and last year in the selected range.</div>';
            
            // Show the significant changes
            landCoverClasses.forEach(className => {
                const firstYearValue = firstYear.area_stats[className] ? firstYear.area_stats[className].percentage : 0;
                const lastYearValue = lastYear.area_stats[className] ? lastYear.area_stats[className].percentage : 0;
                const change = lastYearValue - firstYearValue;
                
                if (Math.abs(change) >= 1.0) { // Only show significant changes (>=1%)
                    const color = change > 0 ? 'green' : 'red';
                    const symbol = change > 0 ? '+' : '';
                    
                    html += `
                        <div class="stat-item">
                            <span class="stat-label">${className}:</span>
                            <span class="stat-value" style="color: ${color}">${symbol}${change.toFixed(1)}% (${firstYearValue.toFixed(1)}% → ${lastYearValue.toFixed(1)}%)</span>
                        </div>
                    `;
                }
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
            
            // Show the Dynamic World legend
            document.getElementById('dynamic-world-legend').style.display = 'block';
        
        } catch (error) {
            console.error('Error displaying Dynamic World time series:', error);
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
                resultsDiv.innerHTML = `<p class="error">Error displaying Dynamic World time series: ${error.message}</p>`;
            }
        }
    }

        // Function to generate Dynamic World forecast
        function generateDynamicWorldForecast(timeseriesData, numYearsToForecast) {
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '<p>Generating Dynamic World forecast...</p>';
    
    try {
        // Use our comprehensive chart reset function
        resetChartCanvases();
                
                // Extract years
                const years = timeseriesData.map(data => data.year);
                const lastYear = Math.max(...years);
                
                // Get all unique land cover classes from the time series
                const landCoverClasses = [];
                const classColors = {};
                const classData = {};
                
                // Initialize with all unique land cover classes across all years
                timeseriesData.forEach(yearData => {
                    Object.entries(yearData.area_stats).forEach(([className, stats]) => {
                        if (!landCoverClasses.includes(className)) {
                            landCoverClasses.push(className);
                            classColors[className] = stats.color;
                            classData[className] = Array(timeseriesData.length).fill(0);
                        }
                    });
                });
                
                // Fill in historical data for each year
                timeseriesData.forEach((yearData, yearIndex) => {
                    landCoverClasses.forEach(className => {
                        if (yearData.area_stats[className]) {
                            classData[className][yearIndex] = yearData.area_stats[className].percentage;
                        }
                    });
                });
                
                // Generate forecast years
                const forecastYears = [];
                for (let i = 1; i <= numYearsToForecast; i++) {
                    forecastYears.push(lastYear + i);
                }
                
                // For each land cover class, calculate trend and forecast future values
                const forecasts = {};
                landCoverClasses.forEach(className => {
                    const values = classData[className];
                    
                    // Use linear regression to predict future values
                    const regression = linearRegression(years, values);
                    
                    // Generate forecast
                    const forecastValues = [];
                    for (let i = 1; i <= numYearsToForecast; i++) {
                        const forecastYear = lastYear + i;
                        const forecastValue = regression.predict(forecastYear);
                        // Ensure values are between 0 and 100
                        forecastValues.push(Math.max(0, Math.min(100, forecastValue)));
                    }
                    
                    forecasts[className] = {
                        historical: values,
                        forecast: forecastValues,
                        regression: regression
                    };
                });
                
                // Create charts showing the forecasts
                createDynamicWorldForecastCharts(years, forecastYears, landCoverClasses, classColors, forecasts);
                
                // Create a summary of significant changes
                displayDynamicWorldForecastSummary(years, forecastYears, landCoverClasses, forecasts, classColors);
        
        // Hide loading screen after successfully generating forecast
        hideLoading();
            } catch (error) {
                console.error('Error generating Dynamic World forecast:', error);
                resultsDiv.innerHTML = `<p class="error">Error generating forecast: ${error.message}</p>`;
        
        // Make sure to hide loading screen on error
        hideLoading();
            }
        }
        
        // Function to create Dynamic World forecast charts
        function createDynamicWorldForecastCharts(historicalYears, forecastYears, landCoverClasses, classColors, forecasts) {
    try {
            // Show the time series container
            const timeSeriesContainer = document.getElementById('time-series-results');
            timeSeriesContainer.style.display = 'block';
            
            // Use our comprehensive chart reset function
            resetChartCanvases();
            
            // Get the context for the charts
            const landCoverCtx = document.getElementById('ndviChart').getContext('2d');
            const distributionCtx = document.getElementById('vegetationChart').getContext('2d');
            
            // Combine years
            const allYears = [...historicalYears, ...forecastYears];
            
            // Sort land cover classes by importance (average percentage)
            const sortedClasses = [...landCoverClasses].sort((a, b) => {
                const avgA = forecasts[a].historical.reduce((sum, val) => sum + val, 0) / historicalYears.length;
                const avgB = forecasts[b].historical.reduce((sum, val) => sum + val, 0) / historicalYears.length;
                return avgB - avgA;
            });
            
            // Limit to top 6 classes for better visualization
            const topClasses = sortedClasses.slice(0, 6);
            
            // Create datasets for each class (historical and forecast)
            const lineDatasets = [];
            
            topClasses.forEach(className => {
                // Historical dataset
                lineDatasets.push({
                    label: `${className} (Historical)`,
                    data: [...forecasts[className].historical, ...Array(forecastYears.length).fill(null)],
                    borderColor: classColors[className],
                    backgroundColor: classColors[className] + '20',
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3
                });
                
                // Forecast dataset
                lineDatasets.push({
                    label: `${className} (Forecast)`,
                    data: [...Array(historicalYears.length).fill(null), ...forecasts[className].forecast],
                    borderColor: classColors[className],
                    borderDash: [5, 5],
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3
                });
            });
            
            // Create the line chart for trends
            window.ndviChart = new Chart(landCoverCtx, {
                type: 'line',
                data: {
                    labels: allYears,
                    datasets: lineDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Dynamic World Land Cover Forecast'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 12,
                                font: {
                                    size: 10
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            stacked: false,
                            title: {
                                display: true,
                                text: 'Percentage of Area (%)'
                            },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
            
            // Create stacked bar chart datasets for visualization
            // Historical stacked bars
            const stackedHistoricalDatasets = topClasses.map(className => ({
                label: `${className} (Historical)`,
                data: [...forecasts[className].historical, ...Array(forecastYears.length).fill(null)],
                backgroundColor: classColors[className],
                stack: 'Historical'
            }));
            
            // Forecast stacked bars
            const stackedForecastDatasets = topClasses.map(className => ({
                label: `${className} (Forecast)`,
                data: [...Array(historicalYears.length).fill(null), ...forecasts[className].forecast],
                backgroundColor: classColors[className] + '90', // More transparent
                stack: 'Forecast',
                borderWidth: 1,
                borderColor: '#555'
            }));
            
            // Combine datasets
            const stackedDatasets = [...stackedHistoricalDatasets, ...stackedForecastDatasets];
            
            // Create the stacked bar chart
            window.vegetationChart = new Chart(distributionCtx, {
                type: 'bar',
                data: {
                    labels: allYears,
                    datasets: stackedDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Land Cover Distribution Forecast'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Year'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Percentage'
                            },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
    } catch (error) {
        console.error('Error creating Dynamic World forecast charts:', error);
        document.getElementById('results').innerHTML = `<p class="error">Error creating forecast charts: ${error.message}</p>`;
        // Add this to ensure loading screen is hidden if chart creation fails
        hideLoading();
    }
        }
        
        // Function to display Dynamic World forecast summary
        function displayDynamicWorldForecastSummary(historicalYears, forecastYears, landCoverClasses, forecasts, classColors) {
    try {
            const resultsDiv = document.getElementById('results');
            
            // Create a forecast summary (replace any existing content)
            let summaryHtml = '<div class="stats-section">';
            summaryHtml += `<div class="stats-title">Dynamic World Land Cover Forecast</div>`;
            summaryHtml += `<div style="font-size: 13px; margin-bottom: 15px; color: #666;">Forecast from ${historicalYears[historicalYears.length-1]} to ${forecastYears[forecastYears.length-1]} based on historical trends.</div>`;
            
            summaryHtml += '<div class="stats-title" style="margin-top: 20px;">Projected Changes</div>';
            
            // Calculate significant changes between last historical year and last forecast year
            const changes = [];
            
            landCoverClasses.forEach(className => {
                const historical = forecasts[className].historical;
                const forecast = forecasts[className].forecast;
                
                const currentValue = historical[historical.length - 1] || 0;
                const futureValue = forecast[forecast.length - 1] || 0;
                const change = futureValue - currentValue;
                
                // Only include significant changes
                if (Math.abs(change) >= 1.0) {
                    changes.push({
                        className,
                        currentValue,
                        futureValue,
                        change,
                        color: classColors[className]
                    });
                }
            });
            
            // Sort by absolute magnitude of change
            changes.sort((a, b) => Math.abs(b.change) - Math.abs(a.change));
            
            // Add significant changes to summary
            if (changes.length > 0) {
                changes.forEach(change => {
                    const changeDirection = change.change > 0 ? 'increase' : 'decrease';
                    const symbol = change.change > 0 ? '+' : '';
                    
                    summaryHtml += `
                        <div class="stat-item">
                            <span class="stat-label">${change.className}:</span>
                            <span class="stat-value" style="color: ${change.change > 0 ? 'green' : 'red'}">
                                ${symbol}${change.change.toFixed(1)}% (${change.currentValue.toFixed(1)}% → ${change.futureValue.toFixed(1)}%)
                            </span>
                        </div>
                    `;
                });
            } else {
                summaryHtml += '<p>No significant changes (≥1%) projected in land cover distribution.</p>';
            }
            
            summaryHtml += '</div>';
            
            // First, check if a forecast container already exists and remove it
            const existingForecastContainer = document.getElementById('forecast-results-container');
            if (existingForecastContainer) {
                existingForecastContainer.remove();
            }
            
            // Create a new container for all forecast-related content
            const forecastContainer = document.createElement('div');
            forecastContainer.id = 'forecast-results-container';
            
            // Add the summary HTML to the container
            forecastContainer.innerHTML = summaryHtml;
            
            // Clear the results div and add our new container
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(forecastContainer);
            
            // Create pie charts comparing current vs. forecasted distribution
            createComparisonPieCharts(historicalYears, forecastYears, landCoverClasses, forecasts, classColors, forecastContainer);
    } catch (error) {
        console.error('Error displaying Dynamic World forecast summary:', error);
        document.getElementById('results').innerHTML = `<p class="error">Error displaying forecast summary: ${error.message}</p>`;
        // Add this to ensure loading screen is hidden if summary creation fails
        hideLoading();
    }
        }
        
        // Function to create comparison pie charts
function createComparisonPieCharts(historicalYears, forecastYears, landCoverClasses, forecasts, classColors, parentContainer) {
    // Create container for pie charts
    const chartsContainer = document.createElement('div');
    chartsContainer.style.display = 'flex';
    chartsContainer.style.flexWrap = 'wrap';
    chartsContainer.style.gap = '20px';
    chartsContainer.style.justifyContent = 'center';
    chartsContainer.style.marginTop = '30px';
    
    // Current (last historical year) container
    const currentContainer = document.createElement('div');
    currentContainer.style.width = '350px';
    currentContainer.style.height = '350px';
    
    // Forecast (last forecast year) container  
    const forecastChartContainer = document.createElement('div');
    forecastChartContainer.style.width = '350px';
    forecastChartContainer.style.height = '350px';
    
    chartsContainer.appendChild(currentContainer);
    chartsContainer.appendChild(forecastChartContainer);
    parentContainer.appendChild(chartsContainer);
            
                // Create canvas elements
    const currentCanvas = document.createElement('canvas');
    currentCanvas.id = 'currentLandCoverPie';
    currentContainer.appendChild(currentCanvas);
    
    const forecastCanvas = document.createElement('canvas');
    forecastCanvas.id = 'forecastLandCoverPie';
    forecastChartContainer.appendChild(forecastCanvas);
            
            // Prepare data for current pie chart
            const currentData = [];
            const forecastData = [];
            const labels = [];
            const backgroundColors = [];
            
            // Filter classes with significant percentage
            landCoverClasses.forEach(className => {
                const historical = forecasts[className].historical;
                const forecast = forecasts[className].forecast;
                
                const currentValue = historical[historical.length - 1] || 0;
                const futureValue = forecast[forecast.length - 1] || 0;
                
                // Only include classes with at least 1% in either current or forecast
                if (currentValue >= 1.0 || futureValue >= 1.0) {
                    labels.push(className);
                    currentData.push(currentValue);
                    forecastData.push(futureValue);
                    backgroundColors.push(classColors[className]);
                }
            });
            
            // Create current distribution pie chart
            new Chart(document.getElementById('currentLandCoverPie').getContext('2d'), {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: currentData,
                        backgroundColor: backgroundColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Current Land Cover (${historicalYears[historicalYears.length-1]})`
                        },
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 12,
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });
            
            // Create forecast distribution pie chart
            new Chart(document.getElementById('forecastLandCoverPie').getContext('2d'), {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: forecastData,
                        backgroundColor: backgroundColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Forecasted Land Cover (${forecastYears[forecastYears.length-1]})`
                        },
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 12,
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });
        }
      
        // Function to fully reset chart canvases and Chart.js registry
function resetChartCanvases() {
    console.log('Fully resetting chart canvases and Chart.js registry');
    
    // Handle all known charts
    const chartInstances = [
        { name: 'ndviChart', prop: 'ndviChart' },
        { name: 'vegetationChart', prop: 'vegetationChart' },
        { name: 'currentLandCoverPie', prop: 'currentLandCoverPie' },
        { name: 'forecastLandCoverPie', prop: 'forecastLandCoverPie' },
        { name: 'currentLandCoverChart', prop: 'currentLandCoverChart' },
        { name: 'forecastLandCoverChart', prop: 'forecastLandCoverChart' },
        { name: 'dynamicWorldChart', prop: 'dynamicWorldChart' }
    ];
    
    // Destroy all chart instances
    chartInstances.forEach(chart => {
        try {
            if (window[chart.prop] instanceof Chart) {
                console.log(`Destroying chart: ${chart.name}`);
                window[chart.prop].destroy();
                window[chart.prop] = null;
            }
        } catch (e) {
            console.error(`Error destroying chart ${chart.name}:`, e);
        }
    });
    
    // Try to clear the Chart.js internal registry if available
    try {
        if (Chart.instances) {
            console.log('Clearing Chart.js registry with', Object.keys(Chart.instances).length, 'instances');
            Object.keys(Chart.instances).forEach(key => {
                try {
                    Chart.instances[key].destroy();
                    console.log(`Destroyed chart instance with key: ${key}`);
                } catch (e) {
                    console.error(`Error destroying chart instance ${key}:`, e);
                }
            });
        }
    } catch (e) {
        console.error('Error clearing Chart.js registry:', e);
    }
    
    // Cleanup without removing existing canvases - this is less aggressive but more reliable
    try {
        // Get all chart containers
        const timeSeriesContainer = document.getElementById('time-series-results');
        const forecastContainer = document.getElementById('forecast-results-container');
        
        // Clear canvas contexts but don't replace elements
        if (timeSeriesContainer) {
            const canvases = timeSeriesContainer.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                try {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    console.log(`Cleared canvas context: ${canvas.id}`);
                } catch (e) {
                    console.error(`Error clearing canvas ${canvas.id}:`, e);
                }
            });
        }
        
        // Clear forecast canvases
        if (forecastContainer) {
            const forecastCanvases = forecastContainer.querySelectorAll('canvas');
            forecastCanvases.forEach(canvas => {
                try {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    console.log(`Cleared forecast canvas context: ${canvas.id}`);
                } catch (e) {
                    console.error(`Error clearing forecast canvas ${canvas.id}:`, e);
                }
            });
        }
    } catch (e) {
        console.error('Error in chart canvas cleanup:', e);
    }
        }

        // Function to clear all map layers for a fresh analysis
        function clearAllMapLayers() {
            console.log('Clearing all map layers for fresh analysis');
            
            // Clear NDVI layer
            if (currentNdviLayer) {
                map.removeLayer(currentNdviLayer);
                currentNdviLayer = null;
                console.log('Cleared current NDVI layer');
            }
            
            // Clear animation layer
            if (animationState.currentLayer) {
                map.removeLayer(animationState.currentLayer);
                animationState.currentLayer = null;
                console.log('Cleared animation layer');
            }
            
            // Stop any running animation
            stopAnimation();
            document.getElementById('animation-controls').classList.remove('visible');
            
            // Clear Dynamic World layer
            if (window.dynamicWorldLayer) {
                map.removeLayer(window.dynamicWorldLayer);
                window.dynamicWorldLayer = null;
                console.log('Cleared Dynamic World layer');
            }
            
            // Clear IGBP layer
            if (window.igbpLayer) {
                map.removeLayer(window.igbpLayer);
                window.igbpLayer = null;
                console.log('Cleared IGBP layer');
            }
            
            // Clear WorldCover layer
            if (window.worldcoverLayer) {
                map.removeLayer(window.worldcoverLayer);
                window.worldcoverLayer = null;
                console.log('Cleared WorldCover layer');
            }
            
            // Reset animation state
            animationState.mapTiles = [];
            animationState.currentIndex = 0;
            animationState.isPlaying = false;
            
            console.log('All map layers cleared');
        }

        // Update the year picker options based on time series analysis
        function updateLandCoverYearOptions() {
            const startYear = parseInt(document.getElementById('start-year').value);
            const endYear = parseInt(document.getElementById('end-year').value);
            const yearSelect = document.getElementById('land-cover-year');
            
            // Clear existing options except the first one
            while (yearSelect.options.length > 1) {
                yearSelect.remove(1);
            }
            
            // Add options for each year in the range
            if (!isNaN(startYear) && !isNaN(endYear)) {
                for (let year = startYear; year <= endYear; year++) {
                    yearSelect.add(new Option(year, year));
                }
                // Select the latest year by default
                yearSelect.value = endYear;
            }
        }
        
        // Update year options when time series is analyzed
        document.getElementById('analyze-time-series-btn').addEventListener('click', function() {
            // The existing event handler code remains the same
            // After the request is complete, update the year options
            setTimeout(updateLandCoverYearOptions, 1000); // Add a delay to ensure data is loaded
        });

        // Add event listener for model type change
        document.querySelector('input[name="model-type"]').addEventListener('change', function() {
            // Get the current model type
            const modelType = document.querySelector('input[name="model-type"]:checked').value;
            console.log(`Model changed to: ${modelType}`);
            
            // Clear existing map layers for fresh analysis
            clearAllMapLayers();
            
            // Reset animation controls
            const controls = document.getElementById('animation-controls');
            controls.classList.remove('visible');
            
            // Reset animation state to prevent issues when switching back
            animationState = {
                mapTiles: [],
                currentIndex: 0,
                isPlaying: false,
                animationSpeed: 1000,
                animationInterval: null,
                currentLayer: null
            };
            
            // Reset any running animations
            stopAnimation();
            
            // Reset the play/pause button appearance
            const playPauseBtn = document.getElementById('play-pause-btn');
            if (playPauseBtn) {
                playPauseBtn.textContent = 'Play';
                playPauseBtn.style.backgroundColor = '#4CAF50';
                playPauseBtn.classList.remove('playing');
            }
            
            // Update the UI based on model selection
            updateLegendVisibility(modelType);
            
            console.log('Animation state reset after model change');
        });

        // Update the NDVI layer when the year is changed in Land Cover Classification
        document.getElementById('land-cover-year').addEventListener('change', function() {
            const selectedYear = this.value;
            const modelType = document.querySelector('input[name="model-type"]:checked').value;
            
            // Only update map layer for NDVI model
            if (modelType === 'ndvi' && selectedYear && currentCoordinates) {
                console.log(`Updating map layer for year: ${selectedYear}`);
                
                // Check if we have saved map tiles from time series analysis
                if (animationState.mapTiles && animationState.mapTiles.length > 0) {
                    // Find the map tile for the selected year
                    const selectedTile = animationState.mapTiles.find(tile => tile.year == selectedYear);
                    
                    if (selectedTile) {
                        // Clear any existing NDVI layer
                        if (currentNdviLayer) {
                            map.removeLayer(currentNdviLayer);
                        }
                        
                        // Add the new NDVI layer for the selected year
                        currentNdviLayer = L.tileLayer(selectedTile.tile_url);
                        
                        // Get the current NDVI opacity
                        const opacity = parseFloat(document.getElementById('ndvi-opacity').value) / 100;
                        currentNdviLayer.setOpacity(opacity);
                        
                        // Add to map if NDVI toggle is checked
                        if (document.getElementById('ndvi-toggle').checked) {
                            currentNdviLayer.addTo(map);
                        }
                        
                        console.log(`Updated NDVI layer to year ${selectedYear}`);
                    } else {
                        console.warn(`No map data available for year ${selectedYear}`);
                    }
                } else {
                    console.warn('No map tiles available. Run Time Series Analysis first.');
                }
            }
        });
        
        // Initialize year selectors when the page loads
        initializeYearSelectors();
    </script>
</body>
</html> 